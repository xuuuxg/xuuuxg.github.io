{"meta":{"title":"xuuuxg","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-04-28T13:49:18.000Z","updated":"2020-04-28T13:49:39.871Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-10T14:07:44.000Z","updated":"2020-05-10T14:08:15.710Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-10T14:08:45.000Z","updated":"2020-05-10T14:08:57.064Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于Spring那些事","slug":"关于Spring那些事","date":"2020-05-17T16:47:16.211Z","updated":"2020-05-17T16:50:38.581Z","comments":true,"path":"2020/05/18/关于Spring那些事/","link":"","permalink":"http://yoursite.com/2020/05/18/%E5%85%B3%E4%BA%8ESpring%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"","text":"关于Spring那些事Spring IOC 什么是IOC？ 这个大家已经非常熟悉了，控制反转。就是将我们的Bean交给Spring容器来控制。 如何使用IOC？ 自动注入 &#x2F;&#x2F; 实体类 @Data public class Student &#123; private int id; private String name; &#125; &#x2F;&#x2F; Repository @Repository @Mapper public class StudentMapper extends BaseMapper&lt;Student&gt;&#123; public User findById(int id); &#125; &#x2F;&#x2F; Service @Service public class StudentService &#123; &#x2F;&#x2F; 自动注入 @Autowired StudentMapper stuMapper; public User findById(int id) &#123; return stuMapper.findById(id); &#125; &#125; &#x2F;&#x2F; 主类 @SpringBootApplication &#x2F;&#x2F; 扫描注入的包 @MapperScan(&quot;com.auto.dao.*&quot;) public class SpringBootMain &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125; &#125; 手动set方式注入 &#x2F;&#x2F; 实体类 @Data public class Student &#123; private int id; private String name; &#125; &#x2F;&#x2F; Repository @Repository @Mapper public class StudentMapper extends BaseMapper&lt;Student&gt;&#123; public User findById(int id); &#125; &#x2F;&#x2F; Service @Service public class StudentService &#123; StudentMapper stuMapper; public void setStuMapper(StudentMapper stuMapper) &#123; this.stuMapper &#x3D; stuMapper; &#125; public User findById(int id) &#123; return stuMapper.findById(id); &#125; &#125; &#x2F;&#x2F; config类 @Configuration public class config &#123; &#x2F;&#x2F; 手动注入Bean @Bean public StudentMapper mapper() &#123; return new StudentMapper(); &#125; @Bean public StudentService stuService() &#123; StudentService s &#x3D; new StudentService(); StudentMapper sM &#x3D; new StudentMapper(); s.setStuMapper(sM); &#125; &#125; 以上代码为两种方式的注入方式。 持续更新","categories":[],"tags":[]},{"title":"阿里云OSS上传文件","slug":"阿里云OSS上传图片","date":"2020-05-16T04:16:57.988Z","updated":"2020-05-16T05:31:11.240Z","comments":true,"path":"2020/05/16/阿里云OSS上传图片/","link":"","permalink":"http://yoursite.com/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/","excerpt":"","text":"阿里云OSS上传存储文件获取accessKeyId、accessKeySecret region与bucket region有一个对照表 https://www.budongyun.com/region/2706/ 创建bucket ​ 然后按照步骤一步一步创建就ok了。 NodeJS实现我使用的是NodeJS来实现的上传图片，因为我觉得没什么必要再上一个Java服务。 &#x2F;&#x2F; 安装两个依赖包 let OSS &#x3D; require(&#39;ali-oss&#39;) let multer &#x3D; require(&#39;multer&#39;); var app &#x3D; express(); app.post(&#39;&#x2F;images&#39;, upload.fields([&#123; name: &#39;file&#39; &#125;]), function (req, res, next) &#123; let client &#x3D; new OSS(&#123; region: &#39;your region&#39;, accessKeyId: &#39;your accessKeyId&#39;, accessKeySecret: &#39;your accessKeySecret&#39;, bucket: &#39;your region&#39;, &#125;); try &#123; &#x2F;&#x2F;第一个参数为图片的名称 第二个参数为图片的buffer流 let result &#x3D; client.put(req.files.file[0].originalname,req.files.file[0].buffer); res.send(&#39;succss&#39;) &#125; catch (e) &#123; res.send(&#39;error&#39;) console.log(e); &#125; &#125;) Vue ElementUI实现使用ElementUI的 组件 &lt;el-upload class&#x3D;&quot;upload-pic&quot; action&#x3D;&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;images&quot; &#x2F;&#x2F;改为你自己的请求路径 :on-preview&#x3D;&quot;handlePreview&quot; :on-remove&#x3D;&quot;handleRemove&quot; :on-success&#x3D;&quot;uploadSuccess&quot; :file-list&#x3D;&quot;fileList&quot; list-type&#x3D;&quot;picture&quot;&gt; &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;点击上传&lt;&#x2F;el-button&gt; &lt;&#x2F;el-upload&gt; --- methods: &#123; handleRemove (file,fileList) &#123; console.log(file) &#125;, handlePreview (file) &#123; console.log(file); &#125;, uploadSuccess () &#123; &#125; &#125;","categories":[],"tags":[]},{"title":"记复习Java","slug":"java","date":"2020-05-14T13:56:45.731Z","updated":"2020-05-18T15:48:08.237Z","comments":true,"path":"2020/05/14/java/","link":"","permalink":"http://yoursite.com/2020/05/14/java/","excerpt":"","text":"记复习Java数组 一维数组 int[] arr &#x3D; &#123;0,1,2,3&#125; for(int i &#x3D; 0; i&lt; arr.length; i++) &#123; arr[i]; &#125; 二维数组 int[][] arr &#x3D; new int[10][10]; 在创建数组的过程中会做这么几件事情： 创建一个长度为10的数组 int[][] arr &#x3D; new int[10][] 遍历再创建长度为10的数组 将2创建的数组赋值为0 for(int i &#x3D; 0; i&lt; 10; i++) &#123; arr[i] &#x3D; new arr[10]; &#125; 我理解二维数组其实是一个变相的一维数组。 方法变量的修饰符 public 修饰方法、变量,所有类、方法都可以访问 protected 修饰方法、变量,同包下、当前类、父子类可以访问 默认的 修饰方法、变量,同包下、当前类可以访问 private 修饰方法、变量,当前类可以访问 this Java中的this都是隐式调用，如果明确调用自己类中的属性可以用到this。 public class PerSon { private int id; private int getId(int id) { return this.id = id; //这里的this就是描述调用类本身的id } //忽略set } 构造器内调用另一个构造器，会用到this。 @Data public class PerSon &#123; private int id; private String name; public PerSon() &#123; this.Cirl(id); &#125; public PerSon(int id) &#123; this.id &#x3D; id; &#125; public PerSon(int id, String name) &#123; this.id &#x3D; id; this.name &#x3D; name; &#125; &#125; this的限制：只能在构造器中第一行出现 可以在代码块中使用 @Data public class PerSon &#123; &#123; this.setId(1); &#125; &#123; this.setName(&quot;小明&quot;); &#125; private int id; private Stirng name; &#125; 上述例子不具备实际开发中的参考，只是示例 扩展类 子类继承超类 使用super关键字调用超类构造器 &#x2F;&#x2F;超类 @Data public class PerSon &#123; private int id; private String name; public PerSon()&#123;&#125; public PerSon(String name) &#123; this.name &#x3D; name; &#125; &#125; &#x2F;&#x2F;子类 public class Man &#123; private int sex; public Man() &#123;&#125; public Man(String name, int sex) &#123; super(name); &#x2F;&#x2F; 使用超类name属性 this.sex &#x3D; sex; &#125; &#125; 多超类的this与super &#x2F;&#x2F; 父类 @Data public class A &#123; private int id; &#125; &#x2F;&#x2F; B继承A @Data public class B extends A&#123; private int id; &#125; &#x2F;&#x2F; C继承B @Data public class C extends B&#123; private int id; &#125; 在C内调用方式： id C的id this.id C的id super(id) B的id ((B)this).getId() B的id ((A)this).getId() A的id","categories":[],"tags":[]},{"title":"关于Node调用Java","slug":"node_Java","date":"2020-05-10T15:03:27.879Z","updated":"2020-05-10T15:04:13.750Z","comments":true,"path":"2020/05/10/node_Java/","link":"","permalink":"http://yoursite.com/2020/05/10/node_Java/","excerpt":"","text":"关于Node调用Java最近在做一个Electron的桌面应用,因为有加密需求,并且加密的包是Java调用硬件单元,所以考虑使用Node调用Java。 思考调用方式当时思考的调用方式有两种 注：应用程序会有无网络的情况 1.将Java包封装到服务内，使用Node调用服务内的接口。这种方式应用于这个Java服务持续的启动着或者Electron应用程序不需要迅速的识别加密的硬件单元。 因为Java服务启动的时间很慢，就算去掉所有的Log日志和其他无用配置，启动也需要4-5秒，Electron应用需要等4-5秒才能检测加密程序，这样用户体验非常不好。 2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar这样做可以快速的调用Java程序，但问题在于java -jar只能调用main内方法，没有返回值，Node就无法获取是否检测到硬件单元，所以就需要一个中间介质。 我选择使用Java调用硬件，然后将硬件单元的返回写在txt文本文档内，最后使用Node读文本文档内的true or false。 Java代码： public static void main(String argv[]) &#123; Boolean a &#x3D; 硬件检测方法; System.out.println(a); String path &#x3D; &quot;文件路径&quot;; File file &#x3D; new File(path); File dir &#x3D; file.getParentFile(); FileWriter fw; if (!dir.exists()) &#123; dir.mkdirs(); &#125; try &#123; fw&#x3D;new FileWriter(file); fw.write(String.valueOf(a)); &#x2F;&#x2F;将返回值写到文本中 fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 现在已经将硬件返回值放到txt文件中，下一步就是用Node读txt文件即可。 Node代码： 因为我的桌面应用是使用Electron-vue来写的，所以要在应用启动的时间加载一下代码，就需要写到App.vue中 const fs &#x3D; require(&#39;fs&#39;); startVbs() &#123; var that &#x3D; this; var time; const defaultPath &#x3D; require(&#39;path&#39;) var defpath &#x3D; defaultPath.join(__dirname, &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39;); &#x2F;&#x2F;获取项目根目录 const exec &#x3D; require(&#39;child_process&#39;).exec; exec(&#39;start &#39; + defpath + &#39;start.vbs&#39;, function (error, stdout, stderr) &#123;&#125;);&#x2F;&#x2F;执行调用Java的脚本，使用vbs是让脚本无cmd弹窗。 clearTimeout(this.timer); &#x2F;&#x2F;清除延迟执行 &#x2F;&#x2F; that.$store.commit(&#39;setRender&#39;, false); this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F;设置延迟执行 that.readIpTxt(); &#125;, 1500); &#125; readText () &#123; var data &#x3D; fs.readFileSync(path).toString(); if (data &#x3D;&#x3D; &quot;true&quot;) &#123; 读出来以后需要做的操作 &#125; &#125; 缺点：启动时需要等待1秒-2秒时间，让Node调用Java脚本。 3.使用Node-JVM这个方法需要安装很多的依赖包。安装无数次都失败了，所以没有尝试，这种方式如果能够npm安装好所有的包，应用是最完美的解决方式。","categories":[],"tags":[]}],"categories":[],"tags":[]}