{"meta":{"title":"xuuuxg","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-04-28T13:49:18.000Z","updated":"2020-04-28T13:49:39.871Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-10T14:07:44.000Z","updated":"2020-05-10T14:08:15.710Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-10T14:08:45.000Z","updated":"2020-05-10T14:08:57.064Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Swagger","slug":"Swagger","date":"2020-08-09T14:22:02.015Z","updated":"2020-08-09T14:28:46.274Z","comments":true,"path":"2020/08/09/Swagger/","link":"","permalink":"http://yoursite.com/2020/08/09/Swagger/","excerpt":"","text":"Swagger使用手册 官方注解文档 SpringBoot集成Swagger 添加依赖 此处为所有依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.41&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;&#x2F;groupId&gt; &lt;artifactId&gt;json-lib&lt;&#x2F;artifactId&gt; &lt;version&gt;2.4&lt;&#x2F;version&gt; &lt;classifier&gt;jdk15&lt;&#x2F;classifier&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;&#x2F;groupId&gt; &lt;artifactId&gt;httpclient&lt;&#x2F;artifactId&gt; &lt;version&gt;4.3.6&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.9&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.45&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt; &lt;version&gt;2.9.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;1.18.12&lt;&#x2F;version&gt; &lt;scope&gt;provided&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; 配置Config @EnableSwagger2 @Configuration @EnableWebMvc public class SwaggerConfig implements WebMvcConfigurer &#123; @Bean public Docket customDocket() &#123; &#x2F;** 这段代码可以不需要添加 意义就是可以让使用swagger时带请求头 ApiInfo apiInfo &#x3D; new ApiInfoBuilder() .title(&quot;项目接口文档&quot;) .description(&quot;项目的接口文档，符合RESTful API&quot;) .version(&quot;1.0&quot;) .build(); ParameterBuilder tokenPar &#x3D; new ParameterBuilder(); List&lt;Parameter&gt; pars &#x3D; new ArrayList&lt;&gt;(); tokenPar.name(&quot;acc_key&quot;).description(&quot;令牌&quot;).modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(false).build(); pars.add(tokenPar.build()); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) &#x2F;&#x2F; .enable(swaggerShow) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.controller&quot;))&#x2F;&#x2F;扫描aa.bb.cc路径下的所有 .paths(PathSelectors.any()) .build() .globalOperationParameters(pars); &#125; @Override &#x2F;&#x2F; 这个实现方法防止出现访问Swagger出现404 public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;swagger-ui.html&quot;) .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;); registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;) .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;); &#125; &#125; 定义Controller @Api(value &#x3D; &quot;用户Controller&quot;, tags &#x3D; &#123;&quot;用户操作接口&quot;&#125;) @RestController @RequestMapping(&quot;&#x2F;users&quot;) public class UserController &#123; @Autowired UserService userService; @RequestMapping(value &#x3D; &quot;&#x2F;user&#x2F;&#123;id&#125;&quot;, method &#x3D; &#123;RequestMethod.GET&#125;) @ApiOperation(value &#x3D; &quot;按照Id查询User&quot;, notes &#x3D; &quot;获取User&quot;) @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;GET UserId required&quot;, dataType &#x3D; &quot;Integer&quot;, paramType &#x3D; &quot;path&quot;) public ResponseEntity getUser(@PathVariable(&quot;id&quot;) Integer id) &#123; return ResponseEntity.ok().body(userService.findUsersById(id)); &#125; &#125; 定义Entity @ApiModel @Data public class UserEntity &#123; @ApiModelProperty(notes &#x3D; &quot;userId&quot;, required &#x3D; false) private int id; @ApiModelProperty(notes &#x3D; &quot;name&quot;, required &#x3D; false) private String name; @ApiModelProperty(notes &#x3D; &quot;tenantId&quot;, hidden &#x3D; true, required &#x3D; false) private int tenantId; &#125; 启动项目 查看日志可以看见 /v2/api-docs ,这就是我们以JSON形式返回API的记录 访问swagger-ui http://IP+PORT/swagger-ui.html，可以看到我们定义的接口，以及使用swagger调用接口 Swagger 注解列表 具体注解可参考官方注解文档 注解 示例 @Api 标记在controller类 @Api(value = “用户Controller”, tags = {“用户操作接口”}) @ApiOperation 标记在controller方法 @ApiOperation(value = “按照Id查询User”, notes = “获取User”) @ApiImplicitParam 标记在controller方法 @ApiImplicitParam(name = “id”, value = “GET UserId required”, dataType = “Integer”, paramType = “path”) @ApiImplicitParams 标记在controller方法（多个参数时使用） @ApiImplicitParams({ @ApiImplicitParam(name = “id1”, value = “GET UserId required”, dataType = “Integer”, paramType = “path”), @ApiImplicitParam(name = “name”, value = “GET UserName”, dataType = “Integer”, paramType = “path”) }) @ApiModel 标记在实体类 @ApiModel @ApiModelProperty 标记在实体类属性 @ApiModelProperty(notes = “name”, required = false) @ApiParam 标记在方法传参属性（其实使用上述ApiImplicitParam 可以替代） @ApiParam(name=”id”, value = “用户id”, required = true) @ApiResponse 标记在controller方法（搭配@ApiResponses一起使用） @ApiResponses(@ApiResponse(code = 400,message = “Invalid”)) @ApiResponses 同上 @Authorization 略 @AuthorizationScope 略","categories":[],"tags":[]},{"title":"关于Spring那些事","slug":"关于Spring那些事","date":"2020-08-09T14:21:39.690Z","updated":"2020-08-09T14:21:39.695Z","comments":true,"path":"2020/08/09/关于Spring那些事/","link":"","permalink":"http://yoursite.com/2020/08/09/%E5%85%B3%E4%BA%8ESpring%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"","text":"关于Spring那些事 名称 进度 Spring IOC 100% Spring AOP 拦截器 监听器 Spring IOC 什么是IOC？ 这个大家已经非常熟悉了，控制反转。就是将我们的Bean交给Spring容器来控制。 如何使用IOC？ 自动注入 &#x2F;&#x2F; 实体类 @Data public class Student &#123; private int id; private String name; &#125; &#x2F;&#x2F; Repository @Repository @Mapper public class StudentMapper extends BaseMapper&lt;Student&gt;&#123; public User findById(int id); &#125; &#x2F;&#x2F; Service @Service public class StudentService &#123; &#x2F;&#x2F; 自动注入 @Autowired StudentMapper stuMapper; public User findById(int id) &#123; return stuMapper.findById(id); &#125; &#125; &#x2F;&#x2F; 主类 @SpringBootApplication &#x2F;&#x2F; 扫描注入的包 @MapperScan(&quot;com.auto.dao.*&quot;) public class SpringBootMain &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125; &#125; 手动set方式注入 &#x2F;&#x2F; 实体类 @Data public class Student &#123; private int id; private String name; &#125; &#x2F;&#x2F; Repository @Repository @Mapper public class StudentMapper extends BaseMapper&lt;Student&gt;&#123; public User findById(int id); &#125; &#x2F;&#x2F; Service @Service public class StudentService &#123; StudentMapper stuMapper; public void setStuMapper(StudentMapper stuMapper) &#123; this.stuMapper &#x3D; stuMapper; &#125; public User findById(int id) &#123; return stuMapper.findById(id); &#125; &#125; &#x2F;&#x2F; config类 @Configuration public class config &#123; &#x2F;&#x2F; 手动注入Bean @Bean public StudentMapper mapper() &#123; return new StudentMapper(); &#125; @Bean public StudentService stuService() &#123; StudentService s &#x3D; new StudentService(); StudentMapper sM &#x3D; new StudentMapper(); s.setStuMapper(sM); &#125; &#125; 以上代码为两种方式的注入方式。 Spring AOP aop是什么？ 通俗易懂的说就是面向切面，那问题又来了，什么是面向切面？ 如下图所示，将程序从中间切开后，植入一些自己的逻辑，就是面向切面。 面向切面的维度有哪些？ 切点（pointcut） 切点就是告知Spring框架，我们要切入方法，但是Spring框架不知道我们要切入哪一个方法，这里就引入了一个 切入点（execution） 的名词。 切入点（execution） 切入点就是让Spring框架知道我们要从哪个方法切入。我们知道切入方法了，但是我想在切入方法前、后或者前后都执行一些其他验证或方法，那就要引入一个 增强（advice） 概念。 增强（advice） 前增强 后增强 方法执行成功后增强 环绕增强 后置异常增强 - 切面（aspect） 切面就是告知Spring框架，我们要切开了，这里就是一个面。 *&lt;u&gt;一个切面可以有多个切点，一个切点上面有多个切入点。&lt;/u&gt;* 那概念解释完我们来看下图。 ![ ](https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/aop3.png) 代码实现 持续更新","categories":[],"tags":[]},{"title":"RabbitMQ","slug":"RabbitMQ","date":"2020-08-09T14:21:18.320Z","updated":"2020-08-09T14:21:18.325Z","comments":true,"path":"2020/08/09/RabbitMQ/","link":"","permalink":"http://yoursite.com/2020/08/09/RabbitMQ/","excerpt":"","text":"RabbitMQ学习安装 安装Erlang依赖 Erlang下载官网 下载对应系统的安装包 安装完毕后安装RabbitMQ Server RabbitMQ官网 如果不安装RabbitMQ Server就会出现连接错误 启动可视化 进入安装目录 我安装的是D盘 进入 D:\\RabbitMQServer\\rabbitmq_server-3.8.4\\sbin 查看用户 rabbitmqctl list_users 默认有一个guest用户，默认密码guest。这个用户有mq所有的权限。 我们也可以创建一个自己的用户 rabbitmqctl add_user xxg xxg --创建用户 xxg 密码为 xxg rabbitmqctl set_permissions xxg &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; --赋予xxg读写所有消息队列的权限 rabbitmqctl set_user_tags xxg administrator --分配用户组 开启插件： rabbitmq-plugins enable rabbitmq_management 查看地址 http://IP:15672 使用创建的用户名进行登录 实现常用交换机模式，分别为 默认交换机、直连交换机、扇形交换机、主题交换机。 当消费者掉线，消息也不会随之丢失。 首先Maven导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 配置Config import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory; import org.springframework.amqp.rabbit.connection.CachingConnectionFactory; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter; import org.springframework.context.annotation.Bean; public class RabbitMQConfig &#123; @Bean public ConnectionFactory connectionFactory() &#123; CachingConnectionFactory connectionFactory &#x3D; new CachingConnectionFactory(); connectionFactory.setAddresses(&quot;localhost:5672&quot;); connectionFactory.setUsername(&quot;xxg&quot;); connectionFactory.setPassword(&quot;xxg&quot;); connectionFactory.setPublisherConfirms(true);&#x2F;&#x2F;消息确认 connectionFactory.setPublisherReturns(true); return connectionFactory; &#125; @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) &#123; RabbitTemplate template &#x3D; new RabbitTemplate(connectionFactory); template.setMessageConverter(new Jackson2JsonMessageConverter()); return template; &#125; @Bean public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory &#x3D; new SimpleRabbitListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); factory.setMessageConverter(new Jackson2JsonMessageConverter()); return factory; &#125; &#125; 默认交换机 默认交换机不需要routingKey来绑定路由，队列名称就是routingkey 生产者 @Component public class Send &#123; private final static String QUEUE_NAME &#x3D; &quot;hello&quot;; @Autowired private RabbitTemplate rabbitTemplate; public void send(String msg) &#123; rabbitTemplate.convertAndSend(this.QUEUE_NAME, msg); &#125; &#125; 消费者 @Component @RabbitListener( queuesToDeclare &#x3D; @Queue(&quot;hello&quot;) ) public class RabbitOnMessage &#123; @RabbitHandler public void onMessage(@Payload String msg) &#123; System.out.println(msg); &#125; &#125; 每当消息生产时后，消费者监听到后就会将该消息消费掉 直连交换机 生产者 @Component public class Send &#123; private final static String EXCHANGE &#x3D; &quot;hello&quot;; @Autowired private RabbitTemplate rabbitTemplate; public void send(String msg) &#123; rabbitTemplate.convertAndSend(this.EXCHANGE,&quot;direct&quot;, msg); &#125; &#125; 消费者 @Component @RabbitListener( bindings &#x3D; @QueueBinding( value &#x3D; @Queue(&quot;DirectQueue&quot;), exchange &#x3D; @Exchange(value &#x3D; &quot;hello&quot;, type &#x3D; ExchangeTypes.DIRECT), key &#x3D; &quot;direct&quot; )) public class RabbitOnMessage &#123; @RabbitHandler public void onMessage(@Payload String msg) &#123; System.out.println(msg); &#125; &#125; 每当消息生产时后，消费者监听到后就会将该消息消费掉 扇形交换机 广播模式 通过交换机名称当做routingKey进行队列绑定 消费者 @Component @RabbitListeners(&#123; @RabbitListener( bindings &#x3D; @QueueBinding( value &#x3D; @Queue(&quot;fountQueue1&quot;), exchange &#x3D; @Exchange(value &#x3D; &quot;fountHello&quot;, type &#x3D; ExchangeTypes.FANOUT), key &#x3D; &quot;one&quot;)), @RabbitListener( bindings &#x3D; @QueueBinding( value &#x3D; @Queue(&quot;fountQueue2&quot;), exchange &#x3D; @Exchange(value &#x3D; &quot;fountHello&quot;, type &#x3D; ExchangeTypes.FANOUT), key &#x3D; &quot;two&quot;) ) &#125;) public class RabbitOnMessage &#123; @RabbitHandler public void onMessage(@Payload String msg) &#123; System.out.println(msg); &#125; &#125; 生产者 @Component public class Send &#123; private final static String EXCHANGE &#x3D; &quot;fountHello&quot;; @Autowired private RabbitTemplate rabbitTemplate; public void send(String msg) &#123; &#x2F;&#x2F; 第一个参数：交换机，第二个参数：routingKey（随意），第三个参数为消费字段 rabbitTemplate.convertAndSend(this.EXCHANGE, &quot;info&quot;,msg); &#125; &#125; 每当消息生产时后，消费者监听到后就会将该消息消费掉 主题交换机 Topics 模式 创建多个消费者，通过routingKey条件匹配进行消费 为匹配一个单词（经实际操作可以匹配两个单词）比如exchange 为 hello.test.topic，匹配规则为 *.topic 也可以匹配 #为匹配一个或多个单词 生产者 @Component public class Send &#123; private final static String Exchange &#x3D; &quot;topic&quot;; private final static String ROUTINGKEY1 &#x3D; &quot;hellop.hello.test.topic&quot;; private final static String ROUTINGKEY2 &#x3D; &quot;hellop.hello.test1.topic&quot;; @Autowired private RabbitTemplate rabbitTemplate; public void send(String msg) &#123; rabbitTemplate.convertAndSend(this.Exchange, this.ROUTINGKEY1,msg); &#125; public void send2(String msg) &#123; rabbitTemplate.convertAndSend(this.Exchange, this.ROUTINGKEY2,msg); &#125; &#125; 消费者 @Component public class RabbitOnMessage &#123; &#x2F;&#x2F; 匹配一个单词 @RabbitListener( bindings &#x3D; @QueueBinding( value &#x3D; @Queue(&quot;onMessage1&quot;), exchange &#x3D; @Exchange(value &#x3D; &quot;topic&quot;, type &#x3D; ExchangeTypes.TOPIC), key &#x3D; &quot;hellop.*.test1.*&quot; ) ) @RabbitHandler public void onMessage1(@Payload String msg, @Headers Map&lt;String, Object&gt; headers) &#123; System.out.println(headers.get(AmqpHeaders.CONSUMER_QUEUE)+&quot;---&quot;+msg); &#125; &#x2F;&#x2F; 匹配多个单词 @RabbitListener( bindings &#x3D; @QueueBinding( value &#x3D; @Queue(&quot;onMessage2&quot;), exchange &#x3D; @Exchange(value &#x3D; &quot;topic&quot;, type &#x3D; ExchangeTypes.TOPIC), key &#x3D; &quot;#.topic&quot; ) ) @RabbitHandler public void onMessage2(@Payload String msg, @Headers Map&lt;String, Object&gt; headers) &#123; System.out.println(headers.get(AmqpHeaders.CONSUMER_QUEUE)+&quot;---&quot;+msg); &#125; &#125; 消费后的结果","categories":[],"tags":[]},{"title":"记Java复习","slug":"java","date":"2020-05-24T13:58:46.850Z","updated":"2020-05-24T13:58:46.850Z","comments":true,"path":"2020/05/24/java/","link":"","permalink":"http://yoursite.com/2020/05/24/java/","excerpt":"","text":"记Java复习数组 一维数组 int[] arr &#x3D; &#123;0,1,2,3&#125; for(int i &#x3D; 0; i&lt; arr.length; i++) &#123; arr[i]; &#125; 二维数组 int[][] arr &#x3D; new int[10][10]; 在创建数组的过程中会做这么几件事情： 创建一个长度为10的数组 int[][] arr &#x3D; new int[10][] 遍历再创建长度为10的数组 将2创建的数组赋值为0 for(int i &#x3D; 0; i&lt; 10; i++) &#123; arr[i] &#x3D; new arr[10]; &#125; 我理解二维数组其实是一个变相的一维数组。 方法变量的修饰符 public 修饰方法、变量,所有类、方法都可以访问 protected 修饰方法、变量,同包下、当前类、父子类可以访问 默认的 修饰方法、变量,同包下、当前类可以访问 private 修饰方法、变量,当前类可以访问 this Java中的this都是隐式调用，如果明确调用自己类中的属性可以用到this。 public class PerSon { private int id; private int getId(int id) { return this.id = id; //这里的this就是描述调用类本身的id } //忽略set } 构造器内调用另一个构造器，会用到this。 @Data public class PerSon &#123; private int id; private String name; public PerSon() &#123; this.Cirl(id); &#125; public PerSon(int id) &#123; this.id &#x3D; id; &#125; public PerSon(int id, String name) &#123; this.id &#x3D; id; this.name &#x3D; name; &#125; &#125; this的限制：只能在构造器中第一行出现 可以在代码块中使用 @Data public class PerSon &#123; &#123; this.setId(1); &#125; &#123; this.setName(&quot;小明&quot;); &#125; private int id; private Stirng name; &#125; 上述例子不具备实际开发中的参考，只是示例 扩展类 子类继承超类 使用super关键字调用超类构造器 &#x2F;&#x2F;超类 @Data public class PerSon &#123; private int id; private String name; public PerSon()&#123;&#125; public PerSon(String name) &#123; this.name &#x3D; name; &#125; &#125; &#x2F;&#x2F;子类 public class Man &#123; private int sex; public Man() &#123;&#125; public Man(String name, int sex) &#123; super(name); &#x2F;&#x2F; 使用超类name属性 this.sex &#x3D; sex; &#125; &#125; 多超类的this与super &#x2F;&#x2F; 父类 @Data public class A &#123; private int id; &#125; &#x2F;&#x2F; B继承A @Data public class B extends A&#123; private int id; &#125; &#x2F;&#x2F; C继承B @Data public class C extends B&#123; private int id; &#125; 在C内调用方式： id C的id this.id C的id super(id) B的id ((B)this).getId() B的id ((A)this).getId() A的id 线程 关于创建线程的两种方式 继承Thread public class TestThread extends Thread &#123; &#x2F;&#x2F; 实现run方法 public void run() &#123; &#x2F;&#x2F; 实现逻辑 &#125; &#125; 启动线程 public class RunThread &#123; public static void main(String...args) &#123; TestThread th &#x3D; new TestThread(); th.start(); &#125; &#125; 实现Runnable public class TestRunnable implement Runnable &#123; @Override public void run() &#123; &#x2F;&#x2F; 业务逻辑 &#125; &#125; 启动线程 public class RunTestRunnable &#123; public static void main(String...args) &#123; TestRunnable tr &#x3D; new TestRunnable(); tr.start(); &#125; &#125; 关于线程传参两种方式 set方式传参 public class TestRunnableParam &#123; &#x2F;&#x2F; 参数实体或属性 private String name; &#x2F;&#x2F; 可写可不写 无惨构造为隐式调用 public TestRunnableParam() &#123;&#125; public String getName() &#123; this.name &#x3D; name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125; &#125; 启动线程 public class RunTestRunnableParam &#123; public static void main(String...args) &#123; String name &#x3D; &quot;小明&quot; TestRunnableParam tr &#x3D; new TestRunnableParam(); tr.setName(name); tr.start(); &#125; &#125; 构造传参 public class TestRunnableParam &#123; &#x2F;&#x2F; 参数实体或属性 private String name; public TestRunnableParam() &#123;&#125; public TestRunnableParam(String name) &#123; this.name &#x3D; name; &#125; &#125; public class RunTestRunnableParam &#123; public static void main(String...args) &#123; String name &#x3D; &quot;小明&quot; TestRunnableParam tr &#x3D; new TestRunnableParam(name); tr.start(); &#125; &#125; 线程锁","categories":[],"tags":[]},{"title":"MybatisPlus多租户","slug":"MybatisPlus多租户","date":"2020-05-24T13:58:46.848Z","updated":"2020-05-24T13:58:46.848Z","comments":true,"path":"2020/05/24/MybatisPlus多租户/","link":"","permalink":"http://yoursite.com/2020/05/24/MybatisPlus%E5%A4%9A%E7%A7%9F%E6%88%B7/","excerpt":"","text":"MybatisPlus多租户 MybatisPlus 官方API 多租户种类 独立数据库 共享数据库，独立Scama 共享数据库，共享Scama（MybatisPlus实现） 多租户实现 我的思路是让多租户的拦截器对系统是没有侵入的 所以采用了监听器的的方式来获取前端传来的租户ID 当然也可以采用将租户ID存在session内或者cookie内 拦截器代码 @WebListener public class CustomListener implements ServletRequestListener &#123; @Autowired private CustomContext customContext; public void requestDestroyed(ServletRequestEvent sre) &#123; &#125; &#x2F;&#x2F; 获取前端传来的 租户ID集合，将租户ID放入请求头内，与请求方式无关 &#x2F;&#x2F; 请求结构：body: &#123;id: &quot;1&quot;&#125;, header: [1,2,3...] &#x2F;&#x2F; 当然租户ID可以为字符串也可以为数字 public void requestInitialized(ServletRequestEvent sre) &#123; HttpServletRequest httpServletRequest &#x3D; (HttpServletRequest) sre.getServletRequest(); String tenantId &#x3D; httpServletRequest.getHeader(&quot;tenantId&quot;); JSONArray jsonArray &#x3D; JSONArray.parseArray(tenantId); Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;(); List&lt;String&gt; tenantIds &#x3D; new ArrayList&lt;&gt;(); if(jsonArray !&#x3D; null) &#123; for(Object tenantIdItem : jsonArray) &#123; System.out.println(tenantIdItem); tenantIds.add(tenantIdItem.toString()); &#125; &#125;else &#123; tenantIds.add(null); &#125; map.put(&quot;tenantIds&quot;,tenantIds); customContext.setTenantIdMap(map); &#125; &#125; CustomContext为自定义的存储数据的上下文类 @Component public class CustomContext &#123; private Map&lt;String, List&lt;String&gt;&gt; tenantIdMap &#x3D; new HashMap&lt;&gt;(); public Map&lt;String, List&lt;String&gt;&gt; getTenantIdMap() &#123; return tenantIdMap; &#125; public void setTenantIdMap(Map&lt;String, List&lt;String&gt;&gt; tenantIdMap) &#123; this.tenantIdMap &#x3D; tenantIdMap; &#125; &#125; 定义MybatisPlus拦截器 @Component public class MybatisInterceptor &#123; @Autowired CustomContext context; @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor &#x3D; new PaginationInterceptor(); List&lt;ISqlParser&gt; sqlParsers &#x3D; new ArrayList&lt;&gt;(); TenantSqlParser tenantSqlParser &#x3D; new TenantSqlParser(); tenantSqlParser.setTenantHandler(new TenantHandler() &#123; @Override public Expression getTenantId(boolean where) &#123; &#x2F;** * where 参数 在官网介绍为 3.2.0版本后添加 * 用于区分多租户ID *&#x2F; final boolean multipleTenantIds &#x3D; false; &#x2F;&#x2F; 用于判断单个租户还是多个租户 if(where &amp;&amp; multipleTenantIds) &#123; return multipleTenantIdCondition(); &#125; &#x2F;&#x2F; 单个租户返回的租户ID return new StringValue(context.getTenantIdMap().get(&quot;tenantIds&quot;).get(0)); &#125; @Override public String getTenantIdColumn() &#123; &#x2F;&#x2F; 告诉MybatisPlus数据库内哪个字段为租户ID return &quot;tenant_id&quot;; &#125; @Override public boolean doTableFilter(String tableName) &#123; &#x2F;&#x2F; 是否做表过滤，因为业务逻辑不同，所以不是所有表都需要添加为租户ID return false; &#125; &#x2F;&#x2F; 单租户的id返回 private Expression singleTenantIdCondition() &#123; return new StringValue(context.getTenantIdMap().get(&quot;tenantId&quot;).get(0)); &#125; &#x2F;&#x2F; 多租户的id返回 private Expression multipleTenantIdCondition() &#123; final InExpression inExpression &#x3D; new InExpression(); inExpression.setLeftExpression(new Column(getTenantIdColumn())); final ExpressionList itemsList &#x3D; new ExpressionList(); &#x2F;&#x2F; 定义一个List final List&lt;Expression&gt; inValues &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 将租户ID放入List for(String tenantId : context.getTenantIdMap().get(&quot;tenantId&quot;)) &#123; inValues.add(new StringValue(tenantId)); &#125; &#x2F;&#x2F; 将List放入ExpressionList对象 itemsList.setExpressions(inValues); &#x2F;&#x2F; 将ExpressionList放入inExpression对象内 inExpression.setRightItemsList(itemsList); return inExpression; &#125; &#125;); &#x2F;&#x2F; 将上述TenantSqlParser内的拦截器放入sqlParser内 sqlParsers.add(tenantSqlParser); &#x2F;&#x2F; 将sqlParser放入paginationInterceptor拦截器内 paginationInterceptor.setSqlParserList(sqlParsers); return paginationInterceptor; &#125; &#125; 忽略Mapper与Service Controller @RestController @RequestMapping(&quot;&#x2F;users&quot;) public class UserController &#123; @Autowired UserService userService; @RequestMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;) &#x2F;&#x2F; 在这个方法内可以看出来，只需要传你所需的查询信息即可 public ResponseEntity getUser@PathVariable(&quot;id&quot;) Integer id)&#123; return ResponseEntity.ok().body(userService.findUsersById(id)); &#125; &#125; 请求 SQL返回 代码已经传github Mybatis多租户","categories":[],"tags":[]},{"title":"阿里云OSS上传文件","slug":"阿里云OSS上传图片","date":"2020-05-16T04:16:57.988Z","updated":"2020-05-24T14:24:47.001Z","comments":true,"path":"2020/05/16/阿里云OSS上传图片/","link":"","permalink":"http://yoursite.com/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/","excerpt":"","text":"阿里云OSS上传存储文件获取accessKeyId、accessKeySecret region与bucket region有一个对照表 https://www.budongyun.com/region/2706/ 创建bucket ​ 然后按照步骤一步一步创建就ok了。 NodeJS实现我使用的是NodeJS来实现的上传图片，因为我觉得没什么必要再上一个Java服务。 &#x2F;&#x2F; 安装两个依赖包 let OSS &#x3D; require(&#39;ali-oss&#39;) let multer &#x3D; require(&#39;multer&#39;); var app &#x3D; express(); app.post(&#39;&#x2F;images&#39;, upload.fields([&#123; name: &#39;file&#39; &#125;]), function (req, res, next) &#123; let client &#x3D; new OSS(&#123; region: &#39;your region&#39;, accessKeyId: &#39;your accessKeyId&#39;, accessKeySecret: &#39;your accessKeySecret&#39;, bucket: &#39;your region&#39;, &#125;); try &#123; &#x2F;&#x2F;第一个参数为图片的名称 第二个参数为图片的buffer流 let result &#x3D; client.put(req.files.file[0].originalname,req.files.file[0].buffer); res.send(&#39;succss&#39;) &#125; catch (e) &#123; res.send(&#39;error&#39;) console.log(e); &#125; &#125;) Vue ElementUI实现使用ElementUI的 组件 &lt;el-upload class&#x3D;&quot;upload-pic&quot; action&#x3D;&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;images&quot; &#x2F;&#x2F;改为你自己的请求路径 :on-preview&#x3D;&quot;handlePreview&quot; :on-remove&#x3D;&quot;handleRemove&quot; :on-success&#x3D;&quot;uploadSuccess&quot; :file-list&#x3D;&quot;fileList&quot; list-type&#x3D;&quot;picture&quot;&gt; &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;点击上传&lt;&#x2F;el-button&gt; &lt;&#x2F;el-upload&gt; --- methods: &#123; handleRemove (file,fileList) &#123; console.log(file) &#125;, handlePreview (file) &#123; console.log(file); &#125;, uploadSuccess () &#123; &#125; &#125; 代码已上传至github","categories":[],"tags":[]},{"title":"关于Node调用Java","slug":"node_Java","date":"2020-05-10T15:03:27.879Z","updated":"2020-05-10T15:04:13.750Z","comments":true,"path":"2020/05/10/node_Java/","link":"","permalink":"http://yoursite.com/2020/05/10/node_Java/","excerpt":"","text":"关于Node调用Java最近在做一个Electron的桌面应用,因为有加密需求,并且加密的包是Java调用硬件单元,所以考虑使用Node调用Java。 思考调用方式当时思考的调用方式有两种 注：应用程序会有无网络的情况 1.将Java包封装到服务内，使用Node调用服务内的接口。这种方式应用于这个Java服务持续的启动着或者Electron应用程序不需要迅速的识别加密的硬件单元。 因为Java服务启动的时间很慢，就算去掉所有的Log日志和其他无用配置，启动也需要4-5秒，Electron应用需要等4-5秒才能检测加密程序，这样用户体验非常不好。 2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar这样做可以快速的调用Java程序，但问题在于java -jar只能调用main内方法，没有返回值，Node就无法获取是否检测到硬件单元，所以就需要一个中间介质。 我选择使用Java调用硬件，然后将硬件单元的返回写在txt文本文档内，最后使用Node读文本文档内的true or false。 Java代码： public static void main(String argv[]) &#123; Boolean a &#x3D; 硬件检测方法; System.out.println(a); String path &#x3D; &quot;文件路径&quot;; File file &#x3D; new File(path); File dir &#x3D; file.getParentFile(); FileWriter fw; if (!dir.exists()) &#123; dir.mkdirs(); &#125; try &#123; fw&#x3D;new FileWriter(file); fw.write(String.valueOf(a)); &#x2F;&#x2F;将返回值写到文本中 fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 现在已经将硬件返回值放到txt文件中，下一步就是用Node读txt文件即可。 Node代码： 因为我的桌面应用是使用Electron-vue来写的，所以要在应用启动的时间加载一下代码，就需要写到App.vue中 const fs &#x3D; require(&#39;fs&#39;); startVbs() &#123; var that &#x3D; this; var time; const defaultPath &#x3D; require(&#39;path&#39;) var defpath &#x3D; defaultPath.join(__dirname, &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39;); &#x2F;&#x2F;获取项目根目录 const exec &#x3D; require(&#39;child_process&#39;).exec; exec(&#39;start &#39; + defpath + &#39;start.vbs&#39;, function (error, stdout, stderr) &#123;&#125;);&#x2F;&#x2F;执行调用Java的脚本，使用vbs是让脚本无cmd弹窗。 clearTimeout(this.timer); &#x2F;&#x2F;清除延迟执行 &#x2F;&#x2F; that.$store.commit(&#39;setRender&#39;, false); this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F;设置延迟执行 that.readIpTxt(); &#125;, 1500); &#125; readText () &#123; var data &#x3D; fs.readFileSync(path).toString(); if (data &#x3D;&#x3D; &quot;true&quot;) &#123; 读出来以后需要做的操作 &#125; &#125; 缺点：启动时需要等待1秒-2秒时间，让Node调用Java脚本。 3.使用Node-JVM这个方法需要安装很多的依赖包。安装无数次都失败了，所以没有尝试，这种方式如果能够npm安装好所有的包，应用是最完美的解决方式。","categories":[],"tags":[]}],"categories":[],"tags":[]}