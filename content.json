{"meta":{"title":"xuuuxg","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-04-28T13:49:18.000Z","updated":"2020-04-28T13:49:39.871Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-10T14:07:44.000Z","updated":"2020-05-10T14:08:15.710Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-10T14:08:45.000Z","updated":"2020-05-10T14:08:57.064Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于Node调用Java","slug":"node_Java","date":"2020-05-10T15:03:27.879Z","updated":"2020-05-10T15:04:13.750Z","comments":true,"path":"2020/05/10/node_Java/","link":"","permalink":"http://yoursite.com/2020/05/10/node_Java/","excerpt":"","text":"关于Node调用Java最近在做一个Electron的桌面应用,因为有加密需求,并且加密的包是Java调用硬件单元,所以考虑使用Node调用Java。 思考调用方式当时思考的调用方式有两种 注：应用程序会有无网络的情况 1.将Java包封装到服务内，使用Node调用服务内的接口。这种方式应用于这个Java服务持续的启动着或者Electron应用程序不需要迅速的识别加密的硬件单元。 因为Java服务启动的时间很慢，就算去掉所有的Log日志和其他无用配置，启动也需要4-5秒，Electron应用需要等4-5秒才能检测加密程序，这样用户体验非常不好。 2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar这样做可以快速的调用Java程序，但问题在于java -jar只能调用main内方法，没有返回值，Node就无法获取是否检测到硬件单元，所以就需要一个中间介质。 我选择使用Java调用硬件，然后将硬件单元的返回写在txt文本文档内，最后使用Node读文本文档内的true or false。 Java代码： public static void main(String argv[]) &#123; Boolean a &#x3D; 硬件检测方法; System.out.println(a); String path &#x3D; &quot;文件路径&quot;; File file &#x3D; new File(path); File dir &#x3D; file.getParentFile(); FileWriter fw; if (!dir.exists()) &#123; dir.mkdirs(); &#125; try &#123; fw&#x3D;new FileWriter(file); fw.write(String.valueOf(a)); &#x2F;&#x2F;将返回值写到文本中 fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 现在已经将硬件返回值放到txt文件中，下一步就是用Node读txt文件即可。 Node代码： 因为我的桌面应用是使用Electron-vue来写的，所以要在应用启动的时间加载一下代码，就需要写到App.vue中 const fs &#x3D; require(&#39;fs&#39;); startVbs() &#123; var that &#x3D; this; var time; const defaultPath &#x3D; require(&#39;path&#39;) var defpath &#x3D; defaultPath.join(__dirname, &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39;); &#x2F;&#x2F;获取项目根目录 const exec &#x3D; require(&#39;child_process&#39;).exec; exec(&#39;start &#39; + defpath + &#39;start.vbs&#39;, function (error, stdout, stderr) &#123;&#125;);&#x2F;&#x2F;执行调用Java的脚本，使用vbs是让脚本无cmd弹窗。 clearTimeout(this.timer); &#x2F;&#x2F;清除延迟执行 &#x2F;&#x2F; that.$store.commit(&#39;setRender&#39;, false); this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F;设置延迟执行 that.readIpTxt(); &#125;, 1500); &#125; readText () &#123; var data &#x3D; fs.readFileSync(path).toString(); if (data &#x3D;&#x3D; &quot;true&quot;) &#123; 读出来以后需要做的操作 &#125; &#125; 缺点：启动时需要等待1秒-2秒时间，让Node调用Java脚本。 3.使用Node-JVM这个方法需要安装很多的依赖包。安装无数次都失败了，所以没有尝试，这种方式如果能够npm安装好所有的包，应用是最完美的解决方式。","categories":[],"tags":[]}],"categories":[],"tags":[]}