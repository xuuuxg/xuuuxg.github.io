<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2020/06/14/Swagger/"/>
    <url>/2020/06/14/Swagger/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2020/06/14/RabbitMQ/"/>
    <url>/2020/06/14/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ学习"><a href="#RabbitMQ学习" class="headerlink" title="RabbitMQ学习"></a>RabbitMQ学习</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>安装Erlang依赖</li></ol><blockquote><p><a href="[https://www.erlang-solutions.com/resources/download.html">Erlang下载官网</a> 下载对应系统的安装包</p></blockquote><p><img src="http://www.xuxinguang.top/Erlang.png" srcset="/img/loading.gif" alt=""></p><p>安装完毕后安装RabbitMQ Server</p><blockquote><p><a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">RabbitMQ官网</a> </p></blockquote><p><img src="http://www.xuxinguang.top/rabbitMQ.png" srcset="/img/loading.gif" alt=""></p><p>如果不安装RabbitMQ Server就会出现连接错误</p><p><img src="http://www.xuxinguang.top/error1.png" srcset="/img/loading.gif" alt=""></p><h3 id="启动可视化"><a href="#启动可视化" class="headerlink" title="启动可视化"></a>启动可视化</h3><ol><li><p>进入安装目录</p><ul><li><p>我安装的是D盘  进入 <u>D:\RabbitMQServer\rabbitmq_server-3.8.4\sbin</u></p></li><li><p>查看用户</p><pre><code class="hljs plain">rabbitmqctl list_users</code></pre><p>默认有一个guest用户，默认密码guest。这个用户有mq所有的权限。</p><p><img src="http://www.xuxinguang.top/rabbitMQInstall1.png" srcset="/img/loading.gif" alt=""></p><p>我们也可以创建一个自己的用户</p><pre><code class="hljs plain">rabbitmqctl add_user  xxg  xxg       --创建用户 xxg  密码为 xxg rabbitmqctl  set_permissions  xxg &quot;.*&quot;  &quot;.*&quot;  &quot;.*&quot;    --赋予xxg读写所有消息队列的权限rabbitmqctl  set_user_tags xxg administrator    --分配用户组</code></pre><p><img src="http://www.xuxinguang.top/rabbitMQInstall2.png" srcset="/img/loading.gif" alt=""></p><p><img src="http://www.xuxinguang.top/rabbitMQInstall3.png" srcset="/img/loading.gif" alt=""></p><p><img src="http://www.xuxinguang.top/rabbitMQInstall4.png" srcset="/img/loading.gif" alt=""></p><p>开启插件：</p><pre><code class="hljs plain">rabbitmq-plugins enable rabbitmq_management</code></pre><p>查看地址 <a href="http://IP:15672" target="_blank" rel="noopener">http://IP:15672</a>    使用创建的用户名进行登录</p><p><img src="http://www.xuxinguang.top/rabbitMQInstall5.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>有五种交换机模式，分别为 广播模式、直接模式、扇形交换机、头交换机、主题交换机。</p><p>当消费者掉线，消息也不会随之丢失。</p><ul><li>首先Maven导入依赖</li></ul><pre><code class="hljs plain">&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre><ul><li>配置Config</li></ul><pre><code class="hljs plain">import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;import org.springframework.amqp.rabbit.connection.ConnectionFactory;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;import org.springframework.context.annotation.Bean;public class RabbitMQConfig &#123;    @Bean    public ConnectionFactory connectionFactory() &#123;        CachingConnectionFactory connectionFactory &#x3D; new CachingConnectionFactory();        connectionFactory.setAddresses(&quot;localhost:5672&quot;);        connectionFactory.setUsername(&quot;xxg&quot;);        connectionFactory.setPassword(&quot;xxg&quot;);        connectionFactory.setPublisherConfirms(true);&#x2F;&#x2F;消息确认        connectionFactory.setPublisherReturns(true);        return connectionFactory;    &#125;    @Bean    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) &#123;        RabbitTemplate template &#x3D; new RabbitTemplate(connectionFactory);        template.setMessageConverter(new Jackson2JsonMessageConverter());        return template;    &#125;    @Bean    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123;        SimpleRabbitListenerContainerFactory factory &#x3D; new SimpleRabbitListenerContainerFactory();        factory.setConnectionFactory(connectionFactory);        factory.setMessageConverter(new Jackson2JsonMessageConverter());        return factory;    &#125;&#125;</code></pre><ol><li>默认交换机</li></ol><p>默认交换机不需要routingKey来绑定路由，可以直接通过队列名称来实现消息的消费</p><p>生产者</p><pre><code class="hljs plain">@Componentpublic class Send &#123;    private final static String QUEUE_NAME &#x3D; &quot;hello&quot;;    @Autowired    private RabbitTemplate rabbitTemplate;    public void send(String msg) &#123;        rabbitTemplate.convertAndSend(this.QUEUE_NAME, msg);    &#125;&#125;</code></pre><p>消费者</p><pre><code class="hljs plain">@Component@RabbitListener(        queuesToDeclare &#x3D; @Queue(&quot;hello&quot;)        )public class RabbitOnMessage &#123;    @RabbitHandler    public void onMessage(@Payload String msg) &#123;        System.out.println(msg);    &#125;&#125;</code></pre><p>每当消息生产时后，消费者监听到后就会将该消息消费掉</p><p><img src="http://www.xuxinguang.top/rabbitMQDefault1.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>直连交换机</li></ol><p>生产者</p><pre><code class="hljs plain">@Componentpublic class Send &#123;    private final static String QUEUE_NAME &#x3D; &quot;hello&quot;;    @Autowired    private RabbitTemplate rabbitTemplate;    public void send(String msg) &#123;        rabbitTemplate.convertAndSend(this.QUEUE_NAME,&quot;direct&quot;, msg);    &#125;&#125;</code></pre><p>消费者</p><pre><code class="hljs plain">@Component@RabbitListener(        bindings &#x3D; @QueueBinding(        value &#x3D; @Queue(&quot;DirectQueue&quot;),        exchange &#x3D; @Exchange(value &#x3D; &quot;hello&quot;, type &#x3D; ExchangeTypes.DIRECT),        key &#x3D; &quot;direct&quot;))public class RabbitOnMessage &#123;    @RabbitHandler    public void onMessage(@Payload String msg) &#123;        System.out.println(msg);    &#125;&#125;</code></pre><p>每当消息生产时后，消费者监听到后就会将该消息消费掉</p><p><img src="http://www.xuxinguang.top/rabbitDirect1.png" srcset="/img/loading.gif" alt=""></p><ol start="3"><li>扇形交换机</li></ol><ol start="3"><li>头交换机</li><li>主题交换机</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Spring那些事</title>
    <link href="/2020/05/24/%E5%85%B3%E4%BA%8ESpring%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2020/05/24/%E5%85%B3%E4%BA%8ESpring%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="关于Spring那些事"><a href="#关于Spring那些事" class="headerlink" title="关于Spring那些事"></a>关于Spring那些事</h2><table><thead><tr><th align="left">名称</th><th>进度</th></tr></thead><tbody><tr><td align="left">Spring IOC</td><td>100%</td></tr><tr><td align="left">Spring AOP</td><td></td></tr><tr><td align="left">拦截器</td><td></td></tr><tr><td align="left">监听器</td><td></td></tr></tbody></table><hr><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><ol><li>什么是IOC？</li></ol><p>这个大家已经非常熟悉了，控制反转。就是将我们的Bean交给Spring容器来控制。</p><ol start="2"><li><p>如何使用IOC？</p><ul><li>自动注入</li></ul><pre><code class="hljs plain">&#x2F;&#x2F; 实体类@Datapublic class Student &#123;private int id;private String name;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; Repository@Repository@Mapperpublic class StudentMapper extends BaseMapper&lt;Student&gt;&#123;public User findById(int id);&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; Service@Servicepublic class StudentService &#123;  &#x2F;&#x2F; 自动注入@AutowiredStudentMapper stuMapper;public User findById(int id) &#123;return stuMapper.findById(id);&#125;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; 主类@SpringBootApplication&#x2F;&#x2F; 扫描注入的包@MapperScan(&quot;com.auto.dao.*&quot;)public class SpringBootMain &#123;      public static void main(String[] args) &#123;         SpringApplication.run(App.class, args);        &#125;  &#125;</code></pre><ul><li>手动set方式注入</li></ul><pre><code class="hljs plain">&#x2F;&#x2F; 实体类@Datapublic class Student &#123;private int id;private String name;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; Repository@Repository@Mapperpublic class StudentMapper extends BaseMapper&lt;Student&gt;&#123;public User findById(int id);&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; Service@Servicepublic class StudentService &#123;StudentMapper stuMapper;public void setStuMapper(StudentMapper stuMapper) &#123;this.stuMapper &#x3D; stuMapper;&#125;public User findById(int id) &#123;return stuMapper.findById(id);&#125;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; config类@Configurationpublic class config &#123;  &#x2F;&#x2F; 手动注入Bean@Beanpublic StudentMapper mapper() &#123;return new StudentMapper();&#125;@Beanpublic StudentService stuService() &#123;StudentService s &#x3D; new StudentService();StudentMapper sM &#x3D; new StudentMapper();s.setStuMapper(sM);&#125;&#125;</code></pre><p>以上代码为两种方式的注入方式。</p><hr><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><ol><li>aop是什么？</li></ol><p>通俗易懂的说就是面向切面，那问题又来了，什么是面向切面？</p><p>如下图所示，将程序从中间切开后，植入一些自己的逻辑，就是面向切面。</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/aop1.png" srcset="/img/loading.gif" alt="面向切面"></p><ol start="2"><li><p>面向切面的维度有哪些？</p><ul><li><p>切点（pointcut）</p><p>切点就是告知Spring框架，我们要切入方法，但是Spring框架不知道我们要切入哪一个方法，这里就引入了一个 <u><em>切入点（execution）</em></u> 的名词。</p><ul><li><p>切入点（execution）</p><p>切入点就是让Spring框架知道我们要从哪个方法切入。我们知道切入方法了，但是我想在切入方法前、后或者前后都执行一些其他验证或方法，那就要引入一个 <u><em>增强（advice）</em></u> 概念。</p><ul><li>增强（advice）<ul><li>前增强</li><li>后增强</li><li>方法执行成功后增强</li><li>环绕增强</li><li>后置异常增强</li></ul></li></ul></li></ul></li><li><p>切面（aspect）</p><p>切面就是告知Spring框架，我们要切开了，这里就是一个面。</p><p><u><em>一个切面可以有多个切点，一个切点上面有多个切入点。</em></u></p></li></ul><p>那概念解释完我们来看下图。</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/aop3.png" srcset="/img/loading.gif" alt="面向切面"></p></li></ol></li></ol><hr><p>   持续更新</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记Java复习</title>
    <link href="/2020/05/24/java/"/>
    <url>/2020/05/24/java/</url>
    
    <content type="html"><![CDATA[<h2 id="记Java复习"><a href="#记Java复习" class="headerlink" title="记Java复习"></a>记Java复习</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>一维数组</p></blockquote><pre><code class="hljs plain">int[] arr &#x3D; &#123;0,1,2,3&#125;for(int i &#x3D; 0; i&lt; arr.length; i++) &#123;arr[i];&#125;</code></pre><blockquote><p>二维数组</p></blockquote><pre><code class="hljs plain">int[][] arr &#x3D; new int[10][10];</code></pre><p>在创建数组的过程中会做这么几件事情：</p><ol><li><p>创建一个长度为10的数组</p><pre><code class="hljs plain">int[][] arr &#x3D; new int[10][]</code></pre></li><li><p>遍历再创建长度为10的数组</p></li><li><p>将2创建的数组赋值为0</p><pre><code class="hljs plain">for(int i &#x3D; 0; i&lt; 10; i++) &#123;arr[i] &#x3D; new arr[10];&#125;</code></pre></li></ol><p>我理解二维数组其实是一个变相的一维数组。</p><hr><h3 id="方法变量的修饰符"><a href="#方法变量的修饰符" class="headerlink" title="方法变量的修饰符"></a>方法变量的修饰符</h3><ol><li><p>public</p><blockquote><p>修饰方法、变量,<u>所有类、方法都可以访问</u></p></blockquote></li><li><p>protected</p><blockquote><p>修饰方法、变量,<u>同包下、当前类、父子类可以访问</u></p></blockquote></li><li><p>默认的</p><blockquote><p>修饰方法、变量,同包下、当前类可以访问</p></blockquote></li><li><p>private</p><blockquote><p>修饰方法、变量,<u>当前类可以访问</u></p></blockquote></li></ol><hr><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol><li><p>Java中的this都是隐式调用，如果明确调用自己类中的属性可以用到this。</p><pre><code>public class PerSon {       private int id;       private int getId(int id) {           return this.id = id;                //这里的this就是描述调用类本身的id       }       //忽略set   }</code></pre></li><li><p>构造器内调用另一个构造器，会用到this。</p><pre><code class="hljs plain">@Datapublic class PerSon &#123;private int id;private String name;public PerSon() &#123;this.Cirl(id);&#125;public PerSon(int id) &#123;this.id &#x3D; id;&#125; public PerSon(int id, String name) &#123;this.id &#x3D; id;this.name &#x3D; name;&#125;&#125;</code></pre><p><u>this的限制：只能在构造器中第一行出现</u></p></li><li><p>可以在代码块中使用</p><pre><code class="hljs plain">@Datapublic class PerSon &#123;&#123;this.setId(1);&#125;&#123;this.setName(&quot;小明&quot;);&#125;private int id;private Stirng name;&#125;</code></pre><p><u>上述例子不具备实际开发中的参考，只是示例</u></p></li></ol><hr><h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><ol><li><p>子类继承超类</p><blockquote><p>使用super关键字调用超类构造器</p></blockquote><pre><code class="hljs plain">&#x2F;&#x2F;超类@Datapublic class PerSon &#123;private int id;private String name;public PerSon()&#123;&#125;public PerSon(String name) &#123;this.name &#x3D; name;&#125;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F;子类public class Man &#123;private int sex;public Man() &#123;&#125;public Man(String name, int sex) &#123;super(name);        &#x2F;&#x2F; 使用超类name属性this.sex &#x3D; sex;&#125;&#125;</code></pre></li><li><p>多超类的this与super</p><pre><code class="hljs plain">&#x2F;&#x2F; 父类@Datapublic class A &#123;private int id;&#125;&#x2F;&#x2F; B继承A@Datapublic class B extends A&#123;private int id;&#125;&#x2F;&#x2F; C继承B@Datapublic class C extends B&#123;private int id;&#125;</code></pre><p>在C内调用方式：</p><blockquote><p>id  C的id</p><p>this.id  C的id</p><p>super(id)  B的id</p><p>((B)this).getId()  B的id</p><p>((A)this).getId()  A的id</p></blockquote></li></ol><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol><li><p>关于创建线程的两种方式</p><ul><li>继承Thread</li></ul><pre><code class="hljs plain">public class TestThread extends Thread &#123;    &#x2F;&#x2F; 实现run方法    public void run() &#123;        &#x2F;&#x2F; 实现逻辑    &#125;&#125;</code></pre><p>启动线程</p><pre><code class="hljs plain">public class RunThread &#123;public static void main(String...args) &#123;TestThread th &#x3D; new TestThread();th.start();&#125;&#125;</code></pre><ul><li>实现Runnable</li></ul><pre><code class="hljs plain">public class TestRunnable implement Runnable &#123;   @Override   public void run() &#123;   &#x2F;&#x2F; 业务逻辑   &#125;   &#125;</code></pre><p>启动线程</p><pre><code class="hljs plain">public class RunTestRunnable &#123;   public static void main(String...args) &#123;   TestRunnable tr &#x3D; new TestRunnable();   tr.start();   &#125;   &#125;</code></pre></li><li><p>关于线程传参两种方式</p><ul><li>set方式传参</li></ul><pre><code class="hljs plain">public class TestRunnableParam &#123;&#x2F;&#x2F; 参数实体或属性private String name;&#x2F;&#x2F; 可写可不写 无惨构造为隐式调用public TestRunnableParam() &#123;&#125;public String getName() &#123;this.name &#x3D; name;&#125;public void setName(String name) &#123;this.name &#x3D; name;&#125;&#125;</code></pre><p>启动线程</p><pre><code class="hljs plain">public class RunTestRunnableParam &#123;public static void main(String...args) &#123;String name &#x3D; &quot;小明&quot;TestRunnableParam tr &#x3D; new TestRunnableParam();tr.setName(name);tr.start();&#125;&#125;</code></pre></li></ol><ul><li><p>构造传参</p><pre><code class="hljs plain">public class TestRunnableParam &#123;&#x2F;&#x2F; 参数实体或属性private String name;public TestRunnableParam() &#123;&#125;public TestRunnableParam(String name) &#123;this.name &#x3D; name;&#125;&#125;</code></pre><pre><code class="hljs plain">public class RunTestRunnableParam &#123;public static void main(String...args) &#123;String name &#x3D; &quot;小明&quot;TestRunnableParam tr &#x3D; new TestRunnableParam(name);tr.start();&#125;&#125;</code></pre></li></ul><ol start="3"><li>线程锁</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus多租户</title>
    <link href="/2020/05/24/MybatisPlus%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    <url>/2020/05/24/MybatisPlus%E5%A4%9A%E7%A7%9F%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="MybatisPlus多租户"><a href="#MybatisPlus多租户" class="headerlink" title="MybatisPlus多租户"></a>MybatisPlus多租户</h2><blockquote><p><a href="https://mp.baomidou.com/guide/tenant.html" target="_blank" rel="noopener">MybatisPlus 官方API</a> </p></blockquote><h3 id="多租户种类"><a href="#多租户种类" class="headerlink" title="多租户种类"></a>多租户种类</h3><ol><li>独立数据库</li><li>共享数据库，独立Scama</li><li>共享数据库，共享Scama（MybatisPlus实现）</li></ol><h3 id="多租户实现"><a href="#多租户实现" class="headerlink" title="多租户实现"></a>多租户实现</h3><blockquote><p>我的思路是让多租户的拦截器对系统是没有侵入的</p><p>所以采用了<u>监听器</u>的的方式来获取<u>前端传来的租户ID</u></p><p>当然也可以采用将租户ID存在session内或者cookie内</p></blockquote><p>拦截器代码</p><pre><code class="hljs plain">@WebListenerpublic class CustomListener implements ServletRequestListener &#123;    @Autowired    private CustomContext customContext;    public void requestDestroyed(ServletRequestEvent sre) &#123;    &#125;&#x2F;&#x2F; 获取前端传来的 租户ID集合，将租户ID放入请求头内，与请求方式无关&#x2F;&#x2F; 请求结构：body: &#123;id: &quot;1&quot;&#125;, header: [1,2,3...]    &#x2F;&#x2F; 当然租户ID可以为字符串也可以为数字    public void requestInitialized(ServletRequestEvent sre) &#123;        HttpServletRequest httpServletRequest &#x3D; (HttpServletRequest) sre.getServletRequest();        String tenantId &#x3D; httpServletRequest.getHeader(&quot;tenantId&quot;);        JSONArray jsonArray &#x3D; JSONArray.parseArray(tenantId);        Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;();        List&lt;String&gt; tenantIds &#x3D; new ArrayList&lt;&gt;();        if(jsonArray !&#x3D; null) &#123;            for(Object tenantIdItem : jsonArray) &#123;                System.out.println(tenantIdItem);                tenantIds.add(tenantIdItem.toString());            &#125;        &#125;else &#123;            tenantIds.add(null);        &#125;        map.put(&quot;tenantIds&quot;,tenantIds);        customContext.setTenantIdMap(map);    &#125;&#125;</code></pre><p>CustomContext为自定义的存储数据的上下文类</p><pre><code class="hljs plain">@Componentpublic class CustomContext &#123;    private Map&lt;String, List&lt;String&gt;&gt; tenantIdMap &#x3D; new HashMap&lt;&gt;();    public Map&lt;String, List&lt;String&gt;&gt; getTenantIdMap() &#123;        return tenantIdMap;    &#125;    public void setTenantIdMap(Map&lt;String, List&lt;String&gt;&gt; tenantIdMap) &#123;        this.tenantIdMap &#x3D; tenantIdMap;    &#125;&#125;</code></pre><p>定义MybatisPlus拦截器</p><pre><code class="hljs plain">@Componentpublic class MybatisInterceptor &#123;    @Autowired    CustomContext context;    @Bean    public PaginationInterceptor paginationInterceptor() &#123;        PaginationInterceptor paginationInterceptor &#x3D; new PaginationInterceptor();        List&lt;ISqlParser&gt; sqlParsers &#x3D; new ArrayList&lt;&gt;();        TenantSqlParser tenantSqlParser &#x3D; new TenantSqlParser();        tenantSqlParser.setTenantHandler(new TenantHandler() &#123;            @Override            public Expression getTenantId(boolean where) &#123;                &#x2F;**                 * where 参数 在官网介绍为   3.2.0版本后添加                 * 用于区分多租户ID                 *&#x2F;                final boolean multipleTenantIds &#x3D; false;   &#x2F;&#x2F; 用于判断单个租户还是多个租户                if(where &amp;&amp; multipleTenantIds) &#123;                    return multipleTenantIdCondition();                &#125;                &#x2F;&#x2F; 单个租户返回的租户ID                return new StringValue(context.getTenantIdMap().get(&quot;tenantIds&quot;).get(0));            &#125;            @Override            public String getTenantIdColumn() &#123;            &#x2F;&#x2F; 告诉MybatisPlus数据库内哪个字段为租户ID                return &quot;tenant_id&quot;;            &#125;            @Override            public boolean doTableFilter(String tableName) &#123;            &#x2F;&#x2F; 是否做表过滤，因为业务逻辑不同，所以不是所有表都需要添加为租户ID                return false;            &#125;            &#x2F;&#x2F; 单租户的id返回            private Expression singleTenantIdCondition() &#123;                return  new StringValue(context.getTenantIdMap().get(&quot;tenantId&quot;).get(0));            &#125;            &#x2F;&#x2F; 多租户的id返回            private Expression multipleTenantIdCondition() &#123;                final InExpression inExpression &#x3D; new InExpression();                inExpression.setLeftExpression(new Column(getTenantIdColumn()));                final ExpressionList itemsList &#x3D; new ExpressionList();                &#x2F;&#x2F; 定义一个List                final List&lt;Expression&gt; inValues &#x3D; new ArrayList&lt;&gt;();                &#x2F;&#x2F; 将租户ID放入List                for(String tenantId : context.getTenantIdMap().get(&quot;tenantId&quot;)) &#123;                    inValues.add(new StringValue(tenantId));                &#125;                &#x2F;&#x2F; 将List放入ExpressionList对象                itemsList.setExpressions(inValues);                &#x2F;&#x2F;  将ExpressionList放入inExpression对象内                inExpression.setRightItemsList(itemsList);                return inExpression;            &#125;        &#125;);                &#x2F;&#x2F; 将上述TenantSqlParser内的拦截器放入sqlParser内        sqlParsers.add(tenantSqlParser);                &#x2F;&#x2F; 将sqlParser放入paginationInterceptor拦截器内        paginationInterceptor.setSqlParserList(sqlParsers);                return paginationInterceptor;    &#125;&#125;</code></pre><p><u>忽略Mapper与Service</u></p><p>Controller</p><pre><code class="hljs plain">@RestController@RequestMapping(&quot;&#x2F;users&quot;)public class UserController &#123;    @Autowired    UserService userService;    @RequestMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)    &#x2F;&#x2F; 在这个方法内可以看出来，只需要传你所需的查询信息即可    public ResponseEntity getUser@PathVariable(&quot;id&quot;) Integer id)&#123;        return ResponseEntity.ok().body(userService.findUsersById(id));    &#125;&#125;</code></pre><p>请求</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/%E5%A4%9A%E7%A7%9F%E6%88%B75.png" srcset="/img/loading.gif" alt="请求"></p><p>SQL返回</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/%E5%A4%9A%E7%A7%9F%E6%88%B74.png" srcset="/img/loading.gif" alt="请求"></p><hr><p>代码已经传github <a href="https://github.com/xuuuxg/MybatisPlusTenant" target="_blank" rel="noopener">Mybatis多租户</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>阿里云OSS上传文件</title>
    <link href="/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <url>/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里云OSS上传存储文件"><a href="#阿里云OSS上传存储文件" class="headerlink" title="阿里云OSS上传存储文件"></a>阿里云OSS上传存储文件</h2><h3 id="获取accessKeyId、accessKeySecret"><a href="#获取accessKeyId、accessKeySecret" class="headerlink" title="获取accessKeyId、accessKeySecret"></a>获取<u>accessKeyId</u>、<u>accessKeySecret</u></h3><ol><li><p><img src="http://www.xuxinguang.top/oss1.png" srcset="/img/loading.gif" alt=""></p></li><li><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/oss2.png" srcset="/img/loading.gif" alt=""></p></li><li><p><img src="http://www.xuxinguang.top/oss3.png" srcset="/img/loading.gif" alt=""></p></li><li><p><img src="http://www.xuxinguang.top/oss3.png" srcset="/img/loading.gif" alt=""></p></li></ol><hr><h3 id="region与bucket"><a href="#region与bucket" class="headerlink" title="region与bucket"></a>region与bucket</h3><ol><li><p>region有一个对照表</p><blockquote><p><a href="https://www.budongyun.com/region/2706/" target="_blank" rel="noopener">https://www.budongyun.com/region/2706/</a></p></blockquote></li><li><p>创建bucket</p><p><img src="http://www.xuxinguang.top/bucket.png" srcset="/img/loading.gif" alt="avatar"></p></li></ol><p>​        然后按照步骤一步一步创建就ok了。</p><hr><h3 id="NodeJS实现"><a href="#NodeJS实现" class="headerlink" title="NodeJS实现"></a>NodeJS实现</h3><p>我使用的是NodeJS来实现的上传图片，因为我觉得没什么必要再上一个Java服务。</p><pre><code class="hljs plain">&#x2F;&#x2F; 安装两个依赖包let OSS &#x3D; require(&#39;ali-oss&#39;)let multer &#x3D; require(&#39;multer&#39;);var app &#x3D; express();app.post(&#39;&#x2F;images&#39;, upload.fields([&#123;  name: &#39;file&#39;&#125;]), function (req, res, next) &#123;  let client &#x3D; new OSS(&#123;    region: &#39;your region&#39;,    accessKeyId: &#39;your accessKeyId&#39;,    accessKeySecret: &#39;your accessKeySecret&#39;,    bucket: &#39;your region&#39;,  &#125;);  try &#123;   &#x2F;&#x2F;第一个参数为图片的名称   第二个参数为图片的buffer流    let result &#x3D; client.put(req.files.file[0].originalname,req.files.file[0].buffer);    res.send(&#39;succss&#39;)  &#125; catch (e) &#123;    res.send(&#39;error&#39;)    console.log(e);  &#125;  &#125;)</code></pre><hr><h3 id="Vue-ElementUI实现"><a href="#Vue-ElementUI实现" class="headerlink" title="Vue ElementUI实现"></a>Vue ElementUI实现</h3><p>使用ElementUI的 <el-upload> 组件</p><pre><code class="hljs plain"> &lt;el-upload class&#x3D;&quot;upload-pic&quot;            action&#x3D;&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;images&quot;     &#x2F;&#x2F;改为你自己的请求路径            :on-preview&#x3D;&quot;handlePreview&quot;            :on-remove&#x3D;&quot;handleRemove&quot;            :on-success&#x3D;&quot;uploadSuccess&quot;            :file-list&#x3D;&quot;fileList&quot;            list-type&#x3D;&quot;picture&quot;&gt;   &lt;el-button size&#x3D;&quot;small&quot;              type&#x3D;&quot;primary&quot;&gt;点击上传&lt;&#x2F;el-button&gt; &lt;&#x2F;el-upload&gt;  ---methods: &#123;   handleRemove (file,fileList) &#123;     console.log(file)   &#125;,   handlePreview (file) &#123;     console.log(file);   &#125;,   uploadSuccess () &#123;   &#125; &#125;</code></pre><hr><p>代码已上传至<a href="https://github.com/xuuuxg" target="_blank" rel="noopener">github</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Node调用Java</title>
    <link href="/2020/05/10/node_Java/"/>
    <url>/2020/05/10/node_Java/</url>
    
    <content type="html"><![CDATA[<h2 id="关于Node调用Java"><a href="#关于Node调用Java" class="headerlink" title="关于Node调用Java"></a>关于Node调用Java</h2><p>最近在做一个Electron的桌面应用,因为有加密需求,并且加密的包是Java调用硬件单元,所以考虑使用Node调用Java。</p><h3 id="思考调用方式"><a href="#思考调用方式" class="headerlink" title="思考调用方式"></a>思考调用方式</h3><p>当时思考的调用方式有两种</p><p>注：应用程序会有无网络的情况</p><h4 id="1-将Java包封装到服务内，使用Node调用服务内的接口。"><a href="#1-将Java包封装到服务内，使用Node调用服务内的接口。" class="headerlink" title="1.将Java包封装到服务内，使用Node调用服务内的接口。"></a>1.将Java包封装到服务内，使用Node调用服务内的接口。</h4><p>这种方式应用于这个Java服务持续的启动着或者Electron应用程序不需要迅速的识别加密的硬件单元。</p><p>因为Java服务启动的时间很慢，就算去掉所有的Log日志和其他无用配置，启动也需要4-5秒，Electron应用需要等4-5秒才能检测加密程序，这样用户体验非常不好。</p><h4 id="2-直接将Java程序打成class文件，使用Node-fs模块exec方法调用java-jar"><a href="#2-直接将Java程序打成class文件，使用Node-fs模块exec方法调用java-jar" class="headerlink" title="2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar"></a>2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar</h4><p>这样做可以快速的调用Java程序，但问题在于java -jar只能调用main内方法，没有返回值，Node就无法获取是否检测到硬件单元，所以就需要一个中间介质。</p><p>我选择使用Java调用硬件，然后将硬件单元的返回写在txt文本文档内，最后使用Node读文本文档内的true or false。</p><p>Java代码：</p><pre><code class="hljs plain">public static void main(String argv[])    &#123;        Boolean a &#x3D; 硬件检测方法;        System.out.println(a);        String path &#x3D; &quot;文件路径&quot;;        File file &#x3D; new File(path);        File dir &#x3D; file.getParentFile();        FileWriter fw;        if (!dir.exists()) &#123;            dir.mkdirs();        &#125;        try &#123;            fw&#x3D;new FileWriter(file);            fw.write(String.valueOf(a));    &#x2F;&#x2F;将返回值写到文本中            fw.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><p>现在已经将硬件返回值放到txt文件中，下一步就是用Node读txt文件即可。</p><p>Node代码：</p><p>因为我的桌面应用是使用Electron-vue来写的，所以要在应用启动的时间加载一下代码，就需要写到App.vue中</p><pre><code class="hljs plain">const fs &#x3D; require(&#39;fs&#39;);startVbs() &#123;    var that &#x3D; this;      var time;      const defaultPath &#x3D; require(&#39;path&#39;)      var defpath &#x3D; defaultPath.join(__dirname, &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39;);    &#x2F;&#x2F;获取项目根目录      const exec &#x3D; require(&#39;child_process&#39;).exec;      exec(&#39;start  &#39; + defpath + &#39;start.vbs&#39;, function (error, stdout, stderr) &#123;&#125;);&#x2F;&#x2F;执行调用Java的脚本，使用vbs是让脚本无cmd弹窗。       clearTimeout(this.timer);  &#x2F;&#x2F;清除延迟执行       &#x2F;&#x2F; that.$store.commit(&#39;setRender&#39;, false);      this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123;   &#x2F;&#x2F;设置延迟执行        that.readIpTxt();      &#125;, 1500);&#125;readText () &#123;  var data &#x3D; fs.readFileSync(path).toString();  if (data &#x3D;&#x3D; &quot;true&quot;) &#123;     读出来以后需要做的操作  &#125;&#125;</code></pre><p>缺点：启动时需要等待1秒-2秒时间，让Node调用Java脚本。</p><h4 id="3-使用Node-JVM"><a href="#3-使用Node-JVM" class="headerlink" title="3.使用Node-JVM"></a>3.使用Node-JVM</h4><p>这个方法需要安装很多的依赖包。安装无数次都失败了，所以没有尝试，这种方式如果能够npm安装好所有的包，应用是最完美的解决方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
