<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2020/06/14/Swagger/"/>
    <url>/2020/06/14/Swagger/</url>
    
    <content type="html"><![CDATA[<h2 id="Swagger使用手册"><a href="#Swagger使用手册" class="headerlink" title="Swagger使用手册"></a>Swagger使用手册</h2><blockquote><p><a href="https://www.javadoc.io/doc/io.swagger/swagger-annotations/1.5.0/index.html" target="_blank" rel="noopener">官方注解文档</a></p></blockquote><h3 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h3><ol><li><p>添加依赖</p><pre><code class="hljs plain">此处为所有依赖&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;   &lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;&lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;   &lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;&lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;&lt;version&gt;1.2.41&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;   &lt;dependency&gt;&lt;groupId&gt;net.sf.json-lib&lt;&#x2F;groupId&gt;&lt;artifactId&gt;json-lib&lt;&#x2F;artifactId&gt;&lt;version&gt;2.4&lt;&#x2F;version&gt;&lt;classifier&gt;jdk15&lt;&#x2F;classifier&gt;&lt;&#x2F;dependency&gt;   &lt;dependency&gt;&lt;groupId&gt;org.apache.httpcomponents&lt;&#x2F;groupId&gt;&lt;artifactId&gt;httpclient&lt;&#x2F;artifactId&gt;&lt;version&gt;4.3.6&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;   &lt;dependency&gt;&lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;&lt;version&gt;3.3.1.tmp&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;&lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;&lt;version&gt;1.1.9&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;   &lt;dependency&gt;&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;version&gt;5.1.45&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;   &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;&lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;&lt;version&gt;2.9.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;   &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;&lt;dependency&gt;&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;&lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;&lt;version&gt;2.9.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;   &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt;&lt;dependency&gt;&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;version&gt;1.18.12&lt;&#x2F;version&gt;&lt;scope&gt;provided&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;</code></pre></li><li><p>配置Config</p><pre><code class="hljs plain">@EnableSwagger2@Configuration@EnableWebMvcpublic class SwaggerConfig implements WebMvcConfigurer &#123;    @Bean    public Docket customDocket() &#123;        &#x2F;**        这段代码可以不需要添加        意义就是可以让使用swagger时带请求头        ParameterBuilder ticketPar &#x3D; new ParameterBuilder();        List&lt;Parameter&gt; pars &#x3D; new ArrayList&lt;Parameter&gt;();        ticketPar.name(&quot;tenantId&quot;).description(&quot;租户ID 为数组[1,2,3,4]&quot;)&#x2F;&#x2F;name表示名称，description表示描述                .modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;)                .required(false).defaultValue(&quot;[1]&quot;).build();&#x2F;&#x2F;required表示是否必填，defaultvalue表示默认值        pars.add(ticketPar.build());&#x2F;&#x2F;添加完此处一定要把下边的带***的也加上否则不生效**&#x2F;        return new Docket(DocumentationType.SWAGGER_2)                .select()                .apis(RequestHandlerSelectors                .basePackage(&quot;com.springapi.controller&quot;))&#x2F;&#x2F;扫描您项目定义路径下的所有                .paths(PathSelectors.any())                .build()                &#x2F;&#x2F;.globalOperationParameters(pars);&#x2F;&#x2F;************把消息头添加;    &#125;    @Override    &#x2F;&#x2F; 这个实现方法防止出现访问Swagger出现404    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;swagger-ui.html&quot;)                .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;);        registry.addResourceHandler(&quot;&#x2F;webjars&#x2F;**&quot;)                .addResourceLocations(&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F;&quot;);    &#125;&#125;</code></pre></li><li><p>定义Controller</p><pre><code class="hljs plain">@Api(value &#x3D; &quot;用户Controller&quot;, tags &#x3D; &#123;&quot;用户操作接口&quot;&#125;)@RestController@RequestMapping(&quot;&#x2F;users&quot;)public class UserController &#123;    @Autowired    UserService userService;    @RequestMapping(value &#x3D; &quot;&#x2F;user&#x2F;&#123;id&#125;&quot;, method &#x3D; &#123;RequestMethod.GET&#125;)    @ApiOperation(value &#x3D; &quot;按照Id查询User&quot;, notes &#x3D; &quot;获取User&quot;)    @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;GET UserId required&quot;, dataType &#x3D; &quot;Integer&quot;, paramType &#x3D; &quot;path&quot;)    public ResponseEntity getUser(@PathVariable(&quot;id&quot;) Integer id) &#123;        return ResponseEntity.ok().body(userService.findUsersById(id));    &#125;&#125;</code></pre></li><li><p>定义Entity</p><pre><code class="hljs plain">@ApiModel@Datapublic class UserEntity &#123;    @ApiModelProperty(notes &#x3D; &quot;userId&quot;, required &#x3D; false)    private int id;    @ApiModelProperty(notes &#x3D; &quot;name&quot;, required &#x3D; false)    private String name;    @ApiModelProperty(notes &#x3D; &quot;tenantId&quot;, hidden &#x3D; true, required &#x3D; false)    private int tenantId;&#125;</code></pre></li></ol><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/swagger1.png" srcset="/img/loading.gif" alt="请求"></p><p>查看日志可以看见 <u><em>/v2/api-docs</em></u> ,这就是我们以JSON形式返回API的记录</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/swagger3.png" srcset="/img/loading.gif" alt="请求"></p><p>访问swagger-ui <a href="http://IP+PORT/swagger-ui.html#/，可以看到我们定义的接口，以及使用swagger调用接口" target="_blank" rel="noopener">http://IP+PORT/swagger-ui.html#/，可以看到我们定义的接口，以及使用swagger调用接口</a></p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/swagger2.png" srcset="/img/loading.gif" alt="请求"></p><h3 id="Swagger-注解列表"><a href="#Swagger-注解列表" class="headerlink" title="Swagger 注解列表"></a>Swagger 注解列表</h3><blockquote><p>具体注解可参考官方注解文档</p></blockquote><table><thead><tr><th align="left">注解</th><th>示例</th></tr></thead><tbody><tr><td align="left">@Api</td><td>标记在controller类                                                                                              @Api(value = “用户Controller”, tags = {“用户操作接口”})</td></tr><tr><td align="left">@ApiOperation</td><td>标记在controller方法                                                                               @ApiOperation(value = “按照Id查询User”, notes = “获取User”)</td></tr><tr><td align="left">@ApiImplicitParam</td><td>标记在controller方法                                                                                                                  @ApiImplicitParam(name = “id”, value = “GET UserId required”, dataType = “Integer”, paramType = “path”)</td></tr><tr><td align="left">@ApiImplicitParams</td><td>标记在controller方法（多个参数时使用）                                                                                @ApiImplicitParams({                                                                                      @ApiImplicitParam(name = “id1”, value = “GET UserId required”, dataType = “Integer”, paramType = “path”),                                                                                               @ApiImplicitParam(name = “name”, value = “GET UserName”, dataType = “Integer”, paramType = “path”)                                                                                                })</td></tr><tr><td align="left">@ApiModel</td><td>标记在实体类                                                                                                                               @ApiModel</td></tr><tr><td align="left">@ApiModelProperty</td><td>标记在实体类属性                                                                                                                  @ApiModelProperty(notes = “name”, required = false)</td></tr><tr><td align="left">@ApiParam</td><td>标记在方法传参属性（其实使用上述ApiImplicitParam 可以替代）                                                                                         @ApiParam(name=”id”, value = “用户id”, required = true)</td></tr><tr><td align="left">@ApiResponse</td><td>标记在controller方法（搭配@ApiResponses一起使用）                                                    @ApiResponses(@ApiResponse(code = 400,message = “Invalid”))</td></tr><tr><td align="left">@ApiResponses</td><td>同上</td></tr><tr><td align="left">@Authorization</td><td>略</td></tr><tr><td align="left">@AuthorizationScope</td><td>略</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2020/06/14/RabbitMQ/"/>
    <url>/2020/06/14/RabbitMQ/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Spring那些事</title>
    <link href="/2020/05/24/%E5%85%B3%E4%BA%8ESpring%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <url>/2020/05/24/%E5%85%B3%E4%BA%8ESpring%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="关于Spring那些事"><a href="#关于Spring那些事" class="headerlink" title="关于Spring那些事"></a>关于Spring那些事</h2><table><thead><tr><th align="left">名称</th><th>进度</th></tr></thead><tbody><tr><td align="left">Spring IOC</td><td>100%</td></tr><tr><td align="left">Spring AOP</td><td></td></tr><tr><td align="left">拦截器</td><td></td></tr><tr><td align="left">监听器</td><td></td></tr></tbody></table><hr><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><ol><li>什么是IOC？</li></ol><p>这个大家已经非常熟悉了，控制反转。就是将我们的Bean交给Spring容器来控制。</p><ol start="2"><li><p>如何使用IOC？</p><ul><li>自动注入</li></ul><pre><code class="hljs plain">&#x2F;&#x2F; 实体类@Datapublic class Student &#123;private int id;private String name;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; Repository@Repository@Mapperpublic class StudentMapper extends BaseMapper&lt;Student&gt;&#123;public User findById(int id);&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; Service@Servicepublic class StudentService &#123;  &#x2F;&#x2F; 自动注入@AutowiredStudentMapper stuMapper;public User findById(int id) &#123;return stuMapper.findById(id);&#125;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; 主类@SpringBootApplication&#x2F;&#x2F; 扫描注入的包@MapperScan(&quot;com.auto.dao.*&quot;)public class SpringBootMain &#123;      public static void main(String[] args) &#123;         SpringApplication.run(App.class, args);        &#125;  &#125;</code></pre><ul><li>手动set方式注入</li></ul><pre><code class="hljs plain">&#x2F;&#x2F; 实体类@Datapublic class Student &#123;private int id;private String name;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; Repository@Repository@Mapperpublic class StudentMapper extends BaseMapper&lt;Student&gt;&#123;public User findById(int id);&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; Service@Servicepublic class StudentService &#123;StudentMapper stuMapper;public void setStuMapper(StudentMapper stuMapper) &#123;this.stuMapper &#x3D; stuMapper;&#125;public User findById(int id) &#123;return stuMapper.findById(id);&#125;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F; config类@Configurationpublic class config &#123;  &#x2F;&#x2F; 手动注入Bean@Beanpublic StudentMapper mapper() &#123;return new StudentMapper();&#125;@Beanpublic StudentService stuService() &#123;StudentService s &#x3D; new StudentService();StudentMapper sM &#x3D; new StudentMapper();s.setStuMapper(sM);&#125;&#125;</code></pre><p>以上代码为两种方式的注入方式。</p><hr><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><ol><li>aop是什么？</li></ol><p>通俗易懂的说就是面向切面，那问题又来了，什么是面向切面？</p><p>如下图所示，将程序从中间切开后，植入一些自己的逻辑，就是面向切面。</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/aop1.png" srcset="/img/loading.gif" alt="面向切面"></p><ol start="2"><li><p>面向切面的维度有哪些？</p><ul><li><p>切点（pointcut）</p><p>切点就是告知Spring框架，我们要切入方法，但是Spring框架不知道我们要切入哪一个方法，这里就引入了一个 <u><em>切入点（execution）</em></u> 的名词。</p><ul><li><p>切入点（execution）</p><p>切入点就是让Spring框架知道我们要从哪个方法切入。我们知道切入方法了，但是我想在切入方法前、后或者前后都执行一些其他验证或方法，那就要引入一个 <u><em>增强（advice）</em></u> 概念。</p><ul><li>增强（advice）<ul><li>前增强</li><li>后增强</li><li>方法执行成功后增强</li><li>环绕增强</li><li>后置异常增强</li></ul></li></ul></li></ul></li><li><p>切面（aspect）</p><p>切面就是告知Spring框架，我们要切开了，这里就是一个面。</p><p><u><em>一个切面可以有多个切点，一个切点上面有多个切入点。</em></u></p></li></ul><p>那概念解释完我们来看下图。</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/aop3.png" srcset="/img/loading.gif" alt="面向切面"></p></li></ol></li></ol><hr><p>   持续更新</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记Java复习</title>
    <link href="/2020/05/24/java/"/>
    <url>/2020/05/24/java/</url>
    
    <content type="html"><![CDATA[<h2 id="记Java复习"><a href="#记Java复习" class="headerlink" title="记Java复习"></a>记Java复习</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>一维数组</p></blockquote><pre><code class="hljs plain">int[] arr &#x3D; &#123;0,1,2,3&#125;for(int i &#x3D; 0; i&lt; arr.length; i++) &#123;arr[i];&#125;</code></pre><blockquote><p>二维数组</p></blockquote><pre><code class="hljs plain">int[][] arr &#x3D; new int[10][10];</code></pre><p>在创建数组的过程中会做这么几件事情：</p><ol><li><p>创建一个长度为10的数组</p><pre><code class="hljs plain">int[][] arr &#x3D; new int[10][]</code></pre></li><li><p>遍历再创建长度为10的数组</p></li><li><p>将2创建的数组赋值为0</p><pre><code class="hljs plain">for(int i &#x3D; 0; i&lt; 10; i++) &#123;arr[i] &#x3D; new arr[10];&#125;</code></pre></li></ol><p>我理解二维数组其实是一个变相的一维数组。</p><hr><h3 id="方法变量的修饰符"><a href="#方法变量的修饰符" class="headerlink" title="方法变量的修饰符"></a>方法变量的修饰符</h3><ol><li><p>public</p><blockquote><p>修饰方法、变量,<u>所有类、方法都可以访问</u></p></blockquote></li><li><p>protected</p><blockquote><p>修饰方法、变量,<u>同包下、当前类、父子类可以访问</u></p></blockquote></li><li><p>默认的</p><blockquote><p>修饰方法、变量,同包下、当前类可以访问</p></blockquote></li><li><p>private</p><blockquote><p>修饰方法、变量,<u>当前类可以访问</u></p></blockquote></li></ol><hr><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol><li><p>Java中的this都是隐式调用，如果明确调用自己类中的属性可以用到this。</p><pre><code>public class PerSon {       private int id;       private int getId(int id) {           return this.id = id;                //这里的this就是描述调用类本身的id       }       //忽略set   }</code></pre></li><li><p>构造器内调用另一个构造器，会用到this。</p><pre><code class="hljs plain">@Datapublic class PerSon &#123;private int id;private String name;public PerSon() &#123;this.Cirl(id);&#125;public PerSon(int id) &#123;this.id &#x3D; id;&#125; public PerSon(int id, String name) &#123;this.id &#x3D; id;this.name &#x3D; name;&#125;&#125;</code></pre><p><u>this的限制：只能在构造器中第一行出现</u></p></li><li><p>可以在代码块中使用</p><pre><code class="hljs plain">@Datapublic class PerSon &#123;&#123;this.setId(1);&#125;&#123;this.setName(&quot;小明&quot;);&#125;private int id;private Stirng name;&#125;</code></pre><p><u>上述例子不具备实际开发中的参考，只是示例</u></p></li></ol><hr><h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><ol><li><p>子类继承超类</p><blockquote><p>使用super关键字调用超类构造器</p></blockquote><pre><code class="hljs plain">&#x2F;&#x2F;超类@Datapublic class PerSon &#123;private int id;private String name;public PerSon()&#123;&#125;public PerSon(String name) &#123;this.name &#x3D; name;&#125;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F;子类public class Man &#123;private int sex;public Man() &#123;&#125;public Man(String name, int sex) &#123;super(name);        &#x2F;&#x2F; 使用超类name属性this.sex &#x3D; sex;&#125;&#125;</code></pre></li><li><p>多超类的this与super</p><pre><code class="hljs plain">&#x2F;&#x2F; 父类@Datapublic class A &#123;private int id;&#125;&#x2F;&#x2F; B继承A@Datapublic class B extends A&#123;private int id;&#125;&#x2F;&#x2F; C继承B@Datapublic class C extends B&#123;private int id;&#125;</code></pre><p>在C内调用方式：</p><blockquote><p>id  C的id</p><p>this.id  C的id</p><p>super(id)  B的id</p><p>((B)this).getId()  B的id</p><p>((A)this).getId()  A的id</p></blockquote></li></ol><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ol><li><p>关于创建线程的两种方式</p><ul><li>继承Thread</li></ul><pre><code class="hljs plain">public class TestThread extends Thread &#123;    &#x2F;&#x2F; 实现run方法    public void run() &#123;        &#x2F;&#x2F; 实现逻辑    &#125;&#125;</code></pre><p>启动线程</p><pre><code class="hljs plain">public class RunThread &#123;public static void main(String...args) &#123;TestThread th &#x3D; new TestThread();th.start();&#125;&#125;</code></pre><ul><li>实现Runnable</li></ul><pre><code class="hljs plain">public class TestRunnable implement Runnable &#123;   @Override   public void run() &#123;   &#x2F;&#x2F; 业务逻辑   &#125;   &#125;</code></pre><p>启动线程</p><pre><code class="hljs plain">public class RunTestRunnable &#123;   public static void main(String...args) &#123;   TestRunnable tr &#x3D; new TestRunnable();   tr.start();   &#125;   &#125;</code></pre></li><li><p>关于线程传参两种方式</p><ul><li>set方式传参</li></ul><pre><code class="hljs plain">public class TestRunnableParam &#123;&#x2F;&#x2F; 参数实体或属性private String name;&#x2F;&#x2F; 可写可不写 无惨构造为隐式调用public TestRunnableParam() &#123;&#125;public String getName() &#123;this.name &#x3D; name;&#125;public void setName(String name) &#123;this.name &#x3D; name;&#125;&#125;</code></pre><p>启动线程</p><pre><code class="hljs plain">public class RunTestRunnableParam &#123;public static void main(String...args) &#123;String name &#x3D; &quot;小明&quot;TestRunnableParam tr &#x3D; new TestRunnableParam();tr.setName(name);tr.start();&#125;&#125;</code></pre></li></ol><ul><li><p>构造传参</p><pre><code class="hljs plain">public class TestRunnableParam &#123;&#x2F;&#x2F; 参数实体或属性private String name;public TestRunnableParam() &#123;&#125;public TestRunnableParam(String name) &#123;this.name &#x3D; name;&#125;&#125;</code></pre><pre><code class="hljs plain">public class RunTestRunnableParam &#123;public static void main(String...args) &#123;String name &#x3D; &quot;小明&quot;TestRunnableParam tr &#x3D; new TestRunnableParam(name);tr.start();&#125;&#125;</code></pre></li></ul><ol start="3"><li>线程锁</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus多租户</title>
    <link href="/2020/05/24/MybatisPlus%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    <url>/2020/05/24/MybatisPlus%E5%A4%9A%E7%A7%9F%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="MybatisPlus多租户"><a href="#MybatisPlus多租户" class="headerlink" title="MybatisPlus多租户"></a>MybatisPlus多租户</h2><blockquote><p><a href="https://mp.baomidou.com/guide/tenant.html" target="_blank" rel="noopener">MybatisPlus 官方API</a> </p></blockquote><h3 id="多租户种类"><a href="#多租户种类" class="headerlink" title="多租户种类"></a>多租户种类</h3><ol><li>独立数据库</li><li>共享数据库，独立Scama</li><li>共享数据库，共享Scama（MybatisPlus实现）</li></ol><h3 id="多租户实现"><a href="#多租户实现" class="headerlink" title="多租户实现"></a>多租户实现</h3><blockquote><p>我的思路是让多租户的拦截器对系统是没有侵入的</p><p>所以采用了<u>监听器</u>的的方式来获取<u>前端传来的租户ID</u></p><p>当然也可以采用将租户ID存在session内或者cookie内</p></blockquote><p>拦截器代码</p><pre><code class="hljs plain">@WebListenerpublic class CustomListener implements ServletRequestListener &#123;    @Autowired    private CustomContext customContext;    public void requestDestroyed(ServletRequestEvent sre) &#123;    &#125;&#x2F;&#x2F; 获取前端传来的 租户ID集合，将租户ID放入请求头内，与请求方式无关&#x2F;&#x2F; 请求结构：body: &#123;id: &quot;1&quot;&#125;, header: [1,2,3...]    &#x2F;&#x2F; 当然租户ID可以为字符串也可以为数字    public void requestInitialized(ServletRequestEvent sre) &#123;        HttpServletRequest httpServletRequest &#x3D; (HttpServletRequest) sre.getServletRequest();        String tenantId &#x3D; httpServletRequest.getHeader(&quot;tenantId&quot;);        JSONArray jsonArray &#x3D; JSONArray.parseArray(tenantId);        Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;();        List&lt;String&gt; tenantIds &#x3D; new ArrayList&lt;&gt;();        if(jsonArray !&#x3D; null) &#123;            for(Object tenantIdItem : jsonArray) &#123;                System.out.println(tenantIdItem);                tenantIds.add(tenantIdItem.toString());            &#125;        &#125;else &#123;            tenantIds.add(null);        &#125;        map.put(&quot;tenantIds&quot;,tenantIds);        customContext.setTenantIdMap(map);    &#125;&#125;</code></pre><p>CustomContext为自定义的存储数据的上下文类</p><pre><code class="hljs plain">@Componentpublic class CustomContext &#123;    private Map&lt;String, List&lt;String&gt;&gt; tenantIdMap &#x3D; new HashMap&lt;&gt;();    public Map&lt;String, List&lt;String&gt;&gt; getTenantIdMap() &#123;        return tenantIdMap;    &#125;    public void setTenantIdMap(Map&lt;String, List&lt;String&gt;&gt; tenantIdMap) &#123;        this.tenantIdMap &#x3D; tenantIdMap;    &#125;&#125;</code></pre><p>定义MybatisPlus拦截器</p><pre><code class="hljs plain">@Componentpublic class MybatisInterceptor &#123;    @Autowired    CustomContext context;    @Bean    public PaginationInterceptor paginationInterceptor() &#123;        PaginationInterceptor paginationInterceptor &#x3D; new PaginationInterceptor();        List&lt;ISqlParser&gt; sqlParsers &#x3D; new ArrayList&lt;&gt;();        TenantSqlParser tenantSqlParser &#x3D; new TenantSqlParser();        tenantSqlParser.setTenantHandler(new TenantHandler() &#123;            @Override            public Expression getTenantId(boolean where) &#123;                &#x2F;**                 * where 参数 在官网介绍为   3.2.0版本后添加                 * 用于区分多租户ID                 *&#x2F;                final boolean multipleTenantIds &#x3D; false;   &#x2F;&#x2F; 用于判断单个租户还是多个租户                if(where &amp;&amp; multipleTenantIds) &#123;                    return multipleTenantIdCondition();                &#125;                &#x2F;&#x2F; 单个租户返回的租户ID                return new StringValue(context.getTenantIdMap().get(&quot;tenantIds&quot;).get(0));            &#125;            @Override            public String getTenantIdColumn() &#123;            &#x2F;&#x2F; 告诉MybatisPlus数据库内哪个字段为租户ID                return &quot;tenant_id&quot;;            &#125;            @Override            public boolean doTableFilter(String tableName) &#123;            &#x2F;&#x2F; 是否做表过滤，因为业务逻辑不同，所以不是所有表都需要添加为租户ID                return false;            &#125;            &#x2F;&#x2F; 单租户的id返回            private Expression singleTenantIdCondition() &#123;                return  new StringValue(context.getTenantIdMap().get(&quot;tenantId&quot;).get(0));            &#125;            &#x2F;&#x2F; 多租户的id返回            private Expression multipleTenantIdCondition() &#123;                final InExpression inExpression &#x3D; new InExpression();                inExpression.setLeftExpression(new Column(getTenantIdColumn()));                final ExpressionList itemsList &#x3D; new ExpressionList();                &#x2F;&#x2F; 定义一个List                final List&lt;Expression&gt; inValues &#x3D; new ArrayList&lt;&gt;();                &#x2F;&#x2F; 将租户ID放入List                for(String tenantId : context.getTenantIdMap().get(&quot;tenantId&quot;)) &#123;                    inValues.add(new StringValue(tenantId));                &#125;                &#x2F;&#x2F; 将List放入ExpressionList对象                itemsList.setExpressions(inValues);                &#x2F;&#x2F;  将ExpressionList放入inExpression对象内                inExpression.setRightItemsList(itemsList);                return inExpression;            &#125;        &#125;);                &#x2F;&#x2F; 将上述TenantSqlParser内的拦截器放入sqlParser内        sqlParsers.add(tenantSqlParser);                &#x2F;&#x2F; 将sqlParser放入paginationInterceptor拦截器内        paginationInterceptor.setSqlParserList(sqlParsers);                return paginationInterceptor;    &#125;&#125;</code></pre><p><u>忽略Mapper与Service</u></p><p>Controller</p><pre><code class="hljs plain">@RestController@RequestMapping(&quot;&#x2F;users&quot;)public class UserController &#123;    @Autowired    UserService userService;    @RequestMapping(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;)    &#x2F;&#x2F; 在这个方法内可以看出来，只需要传你所需的查询信息即可    public ResponseEntity getUser@PathVariable(&quot;id&quot;) Integer id)&#123;        return ResponseEntity.ok().body(userService.findUsersById(id));    &#125;&#125;</code></pre><p>请求</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/%E5%A4%9A%E7%A7%9F%E6%88%B75.png" srcset="/img/loading.gif" alt="请求"></p><p>SQL返回</p><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/%E5%A4%9A%E7%A7%9F%E6%88%B74.png" srcset="/img/loading.gif" alt="请求"></p><hr><p>代码已经传github <a href="https://github.com/xuuuxg/MybatisPlusTenant" target="_blank" rel="noopener">Mybatis多租户</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>阿里云OSS上传文件</title>
    <link href="/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <url>/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里云OSS上传存储文件"><a href="#阿里云OSS上传存储文件" class="headerlink" title="阿里云OSS上传存储文件"></a>阿里云OSS上传存储文件</h2><h3 id="获取accessKeyId、accessKeySecret"><a href="#获取accessKeyId、accessKeySecret" class="headerlink" title="获取accessKeyId、accessKeySecret"></a>获取<u>accessKeyId</u>、<u>accessKeySecret</u></h3><ol><li><p><img src="http://www.xuxinguang.top/oss1.png" srcset="/img/loading.gif" alt=""></p></li><li><p><img src="https://xuuuxgblog.oss-cn-hangzhou.aliyuncs.com/oss2.png" srcset="/img/loading.gif" alt=""></p></li><li><p><img src="http://www.xuxinguang.top/oss3.png" srcset="/img/loading.gif" alt=""></p></li><li><p><img src="http://www.xuxinguang.top/oss3.png" srcset="/img/loading.gif" alt=""></p></li></ol><hr><h3 id="region与bucket"><a href="#region与bucket" class="headerlink" title="region与bucket"></a>region与bucket</h3><ol><li><p>region有一个对照表</p><blockquote><p><a href="https://www.budongyun.com/region/2706/" target="_blank" rel="noopener">https://www.budongyun.com/region/2706/</a></p></blockquote></li><li><p>创建bucket</p><p><img src="http://www.xuxinguang.top/bucket.png" srcset="/img/loading.gif" alt="avatar"></p></li></ol><p>​        然后按照步骤一步一步创建就ok了。</p><hr><h3 id="NodeJS实现"><a href="#NodeJS实现" class="headerlink" title="NodeJS实现"></a>NodeJS实现</h3><p>我使用的是NodeJS来实现的上传图片，因为我觉得没什么必要再上一个Java服务。</p><pre><code class="hljs plain">&#x2F;&#x2F; 安装两个依赖包let OSS &#x3D; require(&#39;ali-oss&#39;)let multer &#x3D; require(&#39;multer&#39;);var app &#x3D; express();app.post(&#39;&#x2F;images&#39;, upload.fields([&#123;  name: &#39;file&#39;&#125;]), function (req, res, next) &#123;  let client &#x3D; new OSS(&#123;    region: &#39;your region&#39;,    accessKeyId: &#39;your accessKeyId&#39;,    accessKeySecret: &#39;your accessKeySecret&#39;,    bucket: &#39;your region&#39;,  &#125;);  try &#123;   &#x2F;&#x2F;第一个参数为图片的名称   第二个参数为图片的buffer流    let result &#x3D; client.put(req.files.file[0].originalname,req.files.file[0].buffer);    res.send(&#39;succss&#39;)  &#125; catch (e) &#123;    res.send(&#39;error&#39;)    console.log(e);  &#125;  &#125;)</code></pre><hr><h3 id="Vue-ElementUI实现"><a href="#Vue-ElementUI实现" class="headerlink" title="Vue ElementUI实现"></a>Vue ElementUI实现</h3><p>使用ElementUI的 <el-upload> 组件</p><pre><code class="hljs plain"> &lt;el-upload class&#x3D;&quot;upload-pic&quot;            action&#x3D;&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;images&quot;     &#x2F;&#x2F;改为你自己的请求路径            :on-preview&#x3D;&quot;handlePreview&quot;            :on-remove&#x3D;&quot;handleRemove&quot;            :on-success&#x3D;&quot;uploadSuccess&quot;            :file-list&#x3D;&quot;fileList&quot;            list-type&#x3D;&quot;picture&quot;&gt;   &lt;el-button size&#x3D;&quot;small&quot;              type&#x3D;&quot;primary&quot;&gt;点击上传&lt;&#x2F;el-button&gt; &lt;&#x2F;el-upload&gt;  ---methods: &#123;   handleRemove (file,fileList) &#123;     console.log(file)   &#125;,   handlePreview (file) &#123;     console.log(file);   &#125;,   uploadSuccess () &#123;   &#125; &#125;</code></pre><hr><p>代码已上传至<a href="https://github.com/xuuuxg" target="_blank" rel="noopener">github</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Node调用Java</title>
    <link href="/2020/05/10/node_Java/"/>
    <url>/2020/05/10/node_Java/</url>
    
    <content type="html"><![CDATA[<h2 id="关于Node调用Java"><a href="#关于Node调用Java" class="headerlink" title="关于Node调用Java"></a>关于Node调用Java</h2><p>最近在做一个Electron的桌面应用,因为有加密需求,并且加密的包是Java调用硬件单元,所以考虑使用Node调用Java。</p><h3 id="思考调用方式"><a href="#思考调用方式" class="headerlink" title="思考调用方式"></a>思考调用方式</h3><p>当时思考的调用方式有两种</p><p>注：应用程序会有无网络的情况</p><h4 id="1-将Java包封装到服务内，使用Node调用服务内的接口。"><a href="#1-将Java包封装到服务内，使用Node调用服务内的接口。" class="headerlink" title="1.将Java包封装到服务内，使用Node调用服务内的接口。"></a>1.将Java包封装到服务内，使用Node调用服务内的接口。</h4><p>这种方式应用于这个Java服务持续的启动着或者Electron应用程序不需要迅速的识别加密的硬件单元。</p><p>因为Java服务启动的时间很慢，就算去掉所有的Log日志和其他无用配置，启动也需要4-5秒，Electron应用需要等4-5秒才能检测加密程序，这样用户体验非常不好。</p><h4 id="2-直接将Java程序打成class文件，使用Node-fs模块exec方法调用java-jar"><a href="#2-直接将Java程序打成class文件，使用Node-fs模块exec方法调用java-jar" class="headerlink" title="2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar"></a>2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar</h4><p>这样做可以快速的调用Java程序，但问题在于java -jar只能调用main内方法，没有返回值，Node就无法获取是否检测到硬件单元，所以就需要一个中间介质。</p><p>我选择使用Java调用硬件，然后将硬件单元的返回写在txt文本文档内，最后使用Node读文本文档内的true or false。</p><p>Java代码：</p><pre><code class="hljs plain">public static void main(String argv[])    &#123;        Boolean a &#x3D; 硬件检测方法;        System.out.println(a);        String path &#x3D; &quot;文件路径&quot;;        File file &#x3D; new File(path);        File dir &#x3D; file.getParentFile();        FileWriter fw;        if (!dir.exists()) &#123;            dir.mkdirs();        &#125;        try &#123;            fw&#x3D;new FileWriter(file);            fw.write(String.valueOf(a));    &#x2F;&#x2F;将返回值写到文本中            fw.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><p>现在已经将硬件返回值放到txt文件中，下一步就是用Node读txt文件即可。</p><p>Node代码：</p><p>因为我的桌面应用是使用Electron-vue来写的，所以要在应用启动的时间加载一下代码，就需要写到App.vue中</p><pre><code class="hljs plain">const fs &#x3D; require(&#39;fs&#39;);startVbs() &#123;    var that &#x3D; this;      var time;      const defaultPath &#x3D; require(&#39;path&#39;)      var defpath &#x3D; defaultPath.join(__dirname, &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39;);    &#x2F;&#x2F;获取项目根目录      const exec &#x3D; require(&#39;child_process&#39;).exec;      exec(&#39;start  &#39; + defpath + &#39;start.vbs&#39;, function (error, stdout, stderr) &#123;&#125;);&#x2F;&#x2F;执行调用Java的脚本，使用vbs是让脚本无cmd弹窗。       clearTimeout(this.timer);  &#x2F;&#x2F;清除延迟执行       &#x2F;&#x2F; that.$store.commit(&#39;setRender&#39;, false);      this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123;   &#x2F;&#x2F;设置延迟执行        that.readIpTxt();      &#125;, 1500);&#125;readText () &#123;  var data &#x3D; fs.readFileSync(path).toString();  if (data &#x3D;&#x3D; &quot;true&quot;) &#123;     读出来以后需要做的操作  &#125;&#125;</code></pre><p>缺点：启动时需要等待1秒-2秒时间，让Node调用Java脚本。</p><h4 id="3-使用Node-JVM"><a href="#3-使用Node-JVM" class="headerlink" title="3.使用Node-JVM"></a>3.使用Node-JVM</h4><p>这个方法需要安装很多的依赖包。安装无数次都失败了，所以没有尝试，这种方式如果能够npm安装好所有的包，应用是最完美的解决方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
