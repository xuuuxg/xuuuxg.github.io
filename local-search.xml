<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>阿里云OSS上传文件</title>
    <link href="/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <url>/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里云OSS上传存储文件"><a href="#阿里云OSS上传存储文件" class="headerlink" title="阿里云OSS上传存储文件"></a>阿里云OSS上传存储文件</h2><h3 id="获取accessKeyId、accessKeySecret"><a href="#获取accessKeyId、accessKeySecret" class="headerlink" title="获取accessKeyId、accessKeySecret"></a>获取<u>accessKeyId</u>、<u>accessKeySecret</u></h3><ol><li><p><a href="http://www.xuxinguang.top/oss1.png" target="_blank" rel="noopener">www.xuxinguang.top/oss1.png</a></p></li><li><p><a href="http://www.xuxinguang.top/oss2.png" target="_blank" rel="noopener">www.xuxinguang.top/oss2.png</a></p></li><li><p><a href="http://www.xuxinguang.top/oss3.png" target="_blank" rel="noopener">www.xuxinguang.top/oss3.png</a></p></li><li><p><a href="http://www.xuxinguang.top/oss4.png" target="_blank" rel="noopener">www.xuxinguang.top/oss4.png</a></p></li></ol><hr><h3 id="region与bucket"><a href="#region与bucket" class="headerlink" title="region与bucket"></a>region与bucket</h3><ol><li><p>region有一个对照表</p><blockquote><p><a href="https://www.budongyun.com/region/2706/" target="_blank" rel="noopener">https://www.budongyun.com/region/2706/</a></p></blockquote></li><li><p>创建bucket</p><p><a href="http://www.xuxinguang.top/bucket.png" target="_blank" rel="noopener">www.xuxinguang.top/bucket.png</a></p></li></ol><p>​        然后按照步骤一步一步创建就ok了。</p><hr><h3 id="NodeJS实现"><a href="#NodeJS实现" class="headerlink" title="NodeJS实现"></a>NodeJS实现</h3><p>我使用的是NodeJS来实现的上传图片，因为我觉得没什么必要再上一个Java服务。</p><pre><code class="hljs plain">&#x2F;&#x2F; 安装两个依赖包let OSS &#x3D; require(&#39;ali-oss&#39;)let multer &#x3D; require(&#39;multer&#39;);var app &#x3D; express();app.post(&#39;&#x2F;images&#39;, upload.fields([&#123;  name: &#39;file&#39;&#125;]), function (req, res, next) &#123;  let client &#x3D; new OSS(&#123;    region: &#39;your region&#39;,    accessKeyId: &#39;your accessKeyId&#39;,    accessKeySecret: &#39;your accessKeySecret&#39;,    bucket: &#39;your region&#39;,  &#125;);  try &#123;   &#x2F;&#x2F;第一个参数为图片的名称   第二个参数为图片的buffer流    let result &#x3D; client.put(req.files.file[0].originalname,req.files.file[0].buffer);    res.send(&#39;succss&#39;)  &#125; catch (e) &#123;    res.send(&#39;error&#39;)    console.log(e);  &#125;  &#125;)</code></pre><hr><h3 id="Vue-ElementUI实现"><a href="#Vue-ElementUI实现" class="headerlink" title="Vue ElementUI实现"></a>Vue ElementUI实现</h3><p>使用ElementUI的 <el-upload> 组件</p><pre><code class="hljs plain"> &lt;el-upload class&#x3D;&quot;upload-pic&quot;            action&#x3D;&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;images&quot;     &#x2F;&#x2F;改为你自己的请求路径            :on-preview&#x3D;&quot;handlePreview&quot;            :on-remove&#x3D;&quot;handleRemove&quot;            :on-success&#x3D;&quot;uploadSuccess&quot;            :file-list&#x3D;&quot;fileList&quot;            list-type&#x3D;&quot;picture&quot;&gt;   &lt;el-button size&#x3D;&quot;small&quot;              type&#x3D;&quot;primary&quot;&gt;点击上传&lt;&#x2F;el-button&gt; &lt;&#x2F;el-upload&gt;  ---methods: &#123;   handleRemove (file,fileList) &#123;     console.log(file)   &#125;,   handlePreview (file) &#123;     console.log(file);   &#125;,   uploadSuccess () &#123;   &#125; &#125;</code></pre><hr><p>代码已上传至<a href="https://github.com/xuuuxg" target="_blank" rel="noopener">github</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记复习Java</title>
    <link href="/2020/05/14/java/"/>
    <url>/2020/05/14/java/</url>
    
    <content type="html"><![CDATA[<h2 id="记复习Java"><a href="#记复习Java" class="headerlink" title="记复习Java"></a>记复习Java</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>一维数组</p></blockquote><pre><code class="hljs plain">int[] arr &#x3D; &#123;0,1,2,3&#125;for(int i &#x3D; 0; i&lt; arr.length; i++) &#123;arr[i];&#125;</code></pre><blockquote><p>二维数组</p></blockquote><pre><code class="hljs plain">int[][] arr &#x3D; new int[10][10];</code></pre><p>在创建数组的过程中会做这么几件事情：</p><ol><li><p>创建一个长度为10的数组</p><pre><code class="hljs plain">int[][] arr &#x3D; new int[10][]</code></pre></li><li><p>遍历再创建长度为10的数组</p></li><li><p>将2创建的数组赋值为0</p><pre><code class="hljs plain">for(int i &#x3D; 0; i&lt; 10; i++) &#123;arr[i] &#x3D; new arr[10];&#125;</code></pre></li></ol><p>我理解二维数组其实是一个变相的一维数组。</p><hr><h5 id="方法变量的修饰符"><a href="#方法变量的修饰符" class="headerlink" title="方法变量的修饰符"></a>方法变量的修饰符</h5><ol><li><p>public</p><blockquote><p>修饰方法、变量,<u>所有类、方法都可以访问</u></p></blockquote></li><li><p>protected</p><blockquote><p>修饰方法、变量,<u>同包下、当前类、父子类可以访问</u></p></blockquote></li><li><p>默认的</p><blockquote><p>修饰方法、变量,同包下、当前类可以访问</p></blockquote></li><li><p>private</p><blockquote><p>修饰方法、变量,<u>当前类可以访问</u></p></blockquote></li></ol><hr><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol><li><p>Java中的this都是隐式调用，如果明确调用自己类中的属性可以用到this。</p><pre><code>public class PerSon {       private int id;       private int getId(int id) {           return this.id = id;                //这里的this就是描述调用类本身的id       }       //忽略set   }</code></pre></li><li><p>构造器内调用另一个构造器，会用到this。</p><pre><code class="hljs plain">@Datapublic class PerSon &#123;private int id;private String name;public PerSon() &#123;this.Cirl(id);&#125;public PerSon(int id) &#123;this.id &#x3D; id;&#125; public PerSon(int id, String name) &#123;this.id &#x3D; id;this.name &#x3D; name;&#125;&#125;</code></pre><p><u>this的限制：只能在构造器中第一行出现</u></p></li><li><p>可以在代码块中使用</p><pre><code class="hljs plain">@Datapublic class PerSon &#123;&#123;this.setId(1);&#125;&#123;this.setName(&quot;小明&quot;);&#125;private int id;private Stirng name;&#125;</code></pre><p><u>上述例子不具备实际开发中的参考，只是示例</u></p></li></ol><hr><h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><ol><li><p>子类继承超类</p><blockquote><p>使用super关键字调用超类构造器</p></blockquote><pre><code class="hljs plain">&#x2F;&#x2F;超类@Datapublic class PerSon &#123;private int id;private String name;public PerSon()&#123;&#125;public PerSon(String name) &#123;this.name &#x3D; name;&#125;&#125;</code></pre><pre><code class="hljs plain">&#x2F;&#x2F;子类public class Man &#123;private int sex;public Man() &#123;&#125;public Man(String name, int sex) &#123;super(name);        &#x2F;&#x2F; 使用超类name属性this.sex &#x3D; sex;&#125;&#125;</code></pre></li><li><p>多超类的this与super</p><pre><code class="hljs plain">&#x2F;&#x2F; 父类@Datapublic class A &#123;private int id;&#125;&#x2F;&#x2F; B继承A@Datapublic class B extends A&#123;private int id;&#125;&#x2F;&#x2F; C继承B@Datapublic class C extends B&#123;private int id;&#125;</code></pre><p>在C内调用方式：</p><blockquote><p>id  C的id</p><p>this.id  C的id</p><p>super(id)  B的id</p><p>((B)this).getId()  B的id</p><p>((A)this).getId()  A的id</p></blockquote></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Node调用Java</title>
    <link href="/2020/05/10/node_Java/"/>
    <url>/2020/05/10/node_Java/</url>
    
    <content type="html"><![CDATA[<h2 id="关于Node调用Java"><a href="#关于Node调用Java" class="headerlink" title="关于Node调用Java"></a>关于Node调用Java</h2><p>最近在做一个Electron的桌面应用,因为有加密需求,并且加密的包是Java调用硬件单元,所以考虑使用Node调用Java。</p><h3 id="思考调用方式"><a href="#思考调用方式" class="headerlink" title="思考调用方式"></a>思考调用方式</h3><p>当时思考的调用方式有两种</p><p>注：应用程序会有无网络的情况</p><h4 id="1-将Java包封装到服务内，使用Node调用服务内的接口。"><a href="#1-将Java包封装到服务内，使用Node调用服务内的接口。" class="headerlink" title="1.将Java包封装到服务内，使用Node调用服务内的接口。"></a>1.将Java包封装到服务内，使用Node调用服务内的接口。</h4><p>这种方式应用于这个Java服务持续的启动着或者Electron应用程序不需要迅速的识别加密的硬件单元。</p><p>因为Java服务启动的时间很慢，就算去掉所有的Log日志和其他无用配置，启动也需要4-5秒，Electron应用需要等4-5秒才能检测加密程序，这样用户体验非常不好。</p><h4 id="2-直接将Java程序打成class文件，使用Node-fs模块exec方法调用java-jar"><a href="#2-直接将Java程序打成class文件，使用Node-fs模块exec方法调用java-jar" class="headerlink" title="2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar"></a>2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar</h4><p>这样做可以快速的调用Java程序，但问题在于java -jar只能调用main内方法，没有返回值，Node就无法获取是否检测到硬件单元，所以就需要一个中间介质。</p><p>我选择使用Java调用硬件，然后将硬件单元的返回写在txt文本文档内，最后使用Node读文本文档内的true or false。</p><p>Java代码：</p><pre><code class="hljs plain">public static void main(String argv[])    &#123;        Boolean a &#x3D; 硬件检测方法;        System.out.println(a);        String path &#x3D; &quot;文件路径&quot;;        File file &#x3D; new File(path);        File dir &#x3D; file.getParentFile();        FileWriter fw;        if (!dir.exists()) &#123;            dir.mkdirs();        &#125;        try &#123;            fw&#x3D;new FileWriter(file);            fw.write(String.valueOf(a));    &#x2F;&#x2F;将返回值写到文本中            fw.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><p>现在已经将硬件返回值放到txt文件中，下一步就是用Node读txt文件即可。</p><p>Node代码：</p><p>因为我的桌面应用是使用Electron-vue来写的，所以要在应用启动的时间加载一下代码，就需要写到App.vue中</p><pre><code class="hljs plain">const fs &#x3D; require(&#39;fs&#39;);startVbs() &#123;    var that &#x3D; this;      var time;      const defaultPath &#x3D; require(&#39;path&#39;)      var defpath &#x3D; defaultPath.join(__dirname, &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39;);    &#x2F;&#x2F;获取项目根目录      const exec &#x3D; require(&#39;child_process&#39;).exec;      exec(&#39;start  &#39; + defpath + &#39;start.vbs&#39;, function (error, stdout, stderr) &#123;&#125;);&#x2F;&#x2F;执行调用Java的脚本，使用vbs是让脚本无cmd弹窗。       clearTimeout(this.timer);  &#x2F;&#x2F;清除延迟执行       &#x2F;&#x2F; that.$store.commit(&#39;setRender&#39;, false);      this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123;   &#x2F;&#x2F;设置延迟执行        that.readIpTxt();      &#125;, 1500);&#125;readText () &#123;  var data &#x3D; fs.readFileSync(path).toString();  if (data &#x3D;&#x3D; &quot;true&quot;) &#123;     读出来以后需要做的操作  &#125;&#125;</code></pre><p>缺点：启动时需要等待1秒-2秒时间，让Node调用Java脚本。</p><h4 id="3-使用Node-JVM"><a href="#3-使用Node-JVM" class="headerlink" title="3.使用Node-JVM"></a>3.使用Node-JVM</h4><p>这个方法需要安装很多的依赖包。安装无数次都失败了，所以没有尝试，这种方式如果能够npm安装好所有的包，应用是最完美的解决方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
