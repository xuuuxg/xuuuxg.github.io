<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于Node调用Java</title>
    <link href="/2020/05/10/node_Java/"/>
    <url>/2020/05/10/node_Java/</url>
    
    <content type="html"><![CDATA[<h2 id="关于Node调用Java"><a href="#关于Node调用Java" class="headerlink" title="关于Node调用Java"></a>关于Node调用Java</h2><p>最近在做一个Electron的桌面应用,因为有加密需求,并且加密的包是Java调用硬件单元,所以考虑使用Node调用Java。</p><h3 id="思考调用方式"><a href="#思考调用方式" class="headerlink" title="思考调用方式"></a>思考调用方式</h3><p>当时思考的调用方式有两种</p><p>注：应用程序会有无网络的情况</p><h4 id="1-将Java包封装到服务内，使用Node调用服务内的接口。"><a href="#1-将Java包封装到服务内，使用Node调用服务内的接口。" class="headerlink" title="1.将Java包封装到服务内，使用Node调用服务内的接口。"></a>1.将Java包封装到服务内，使用Node调用服务内的接口。</h4><p>这种方式应用于这个Java服务持续的启动着或者Electron应用程序不需要迅速的识别加密的硬件单元。</p><p>因为Java服务启动的时间很慢，就算去掉所有的Log日志和其他无用配置，启动也需要4-5秒，Electron应用需要等4-5秒才能检测加密程序，这样用户体验非常不好。</p><h4 id="2-直接将Java程序打成class文件，使用Node-fs模块exec方法调用java-jar"><a href="#2-直接将Java程序打成class文件，使用Node-fs模块exec方法调用java-jar" class="headerlink" title="2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar"></a>2.直接将Java程序打成class文件，使用Node fs模块exec方法调用java -jar</h4><p>这样做可以快速的调用Java程序，但问题在于java -jar只能调用main内方法，没有返回值，Node就无法获取是否检测到硬件单元，所以就需要一个中间介质。</p><p>我选择使用Java调用硬件，然后将硬件单元的返回写在txt文本文档内，最后使用Node读文本文档内的true or false。</p><p>Java代码：</p><pre><code class="hljs plain">public static void main(String argv[])    &#123;        Boolean a &#x3D; 硬件检测方法;        System.out.println(a);        String path &#x3D; &quot;文件路径&quot;;        File file &#x3D; new File(path);        File dir &#x3D; file.getParentFile();        FileWriter fw;        if (!dir.exists()) &#123;            dir.mkdirs();        &#125;        try &#123;            fw&#x3D;new FileWriter(file);            fw.write(String.valueOf(a));    &#x2F;&#x2F;将返回值写到文本中            fw.close();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><p>现在已经将硬件返回值放到txt文件中，下一步就是用Node读txt文件即可。</p><p>Node代码：</p><p>因为我的桌面应用是使用Electron-vue来写的，所以要在应用启动的时间加载一下代码，就需要写到App.vue中</p><pre><code class="hljs plain">const fs &#x3D; require(&#39;fs&#39;);startVbs() &#123;    var that &#x3D; this;      var time;      const defaultPath &#x3D; require(&#39;path&#39;)      var defpath &#x3D; defaultPath.join(__dirname, &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39;);    &#x2F;&#x2F;获取项目根目录      const exec &#x3D; require(&#39;child_process&#39;).exec;      exec(&#39;start  &#39; + defpath + &#39;start.vbs&#39;, function (error, stdout, stderr) &#123;&#125;);&#x2F;&#x2F;执行调用Java的脚本，使用vbs是让脚本无cmd弹窗。       clearTimeout(this.timer);  &#x2F;&#x2F;清除延迟执行       &#x2F;&#x2F; that.$store.commit(&#39;setRender&#39;, false);      this.timer &#x3D; setTimeout(() &#x3D;&gt; &#123;   &#x2F;&#x2F;设置延迟执行        that.readIpTxt();      &#125;, 1500);&#125;readText () &#123;  var data &#x3D; fs.readFileSync(path).toString();  if (data &#x3D;&#x3D; &quot;true&quot;) &#123;     读出来以后需要做的操作  &#125;&#125;</code></pre><p>缺点：启动时需要等待1秒-2秒时间，让Node调用Java脚本。</p><h4 id="3-使用Node-JVM"><a href="#3-使用Node-JVM" class="headerlink" title="3.使用Node-JVM"></a>3.使用Node-JVM</h4><p>这个方法需要安装很多的依赖包。安装无数次都失败了，所以没有尝试，这种方式如果能够npm安装好所有的包，应用是最完美的解决方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
